{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs nique t aleres","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre> <p>Liste \u00e0 puce:</p> <ul> <li>Element 1</li> <li>Sous-\u00e9l\u00e9ment 1</li> <li>Sous-\u00e9l\u00e9ment 2</li> <li>Element 2</li> <li>Element 3</li> </ul> <p>Texte en gras</p> <p>texte mis en \u00e9vidence en vert</p>"},{"location":"Bt/","title":"Py Trees for ROS","text":""},{"location":"Bt/#sequence","title":"S\u00e9quence","text":"<p>La sequence va executer ses enfants un \u00e0 un dans un ordre pr\u00e9d\u00e9finit, si un enfant lui renvoi SUCCESS alors il passe \u00e0 l'autre, si tous les enfant renvoient SUCESS alors il renvoi SUCCESS, si un enfants renvoient FAILURE alors il arrete la s\u00e9quence et renvoi FAILURE</p>"},{"location":"Bt/#selector","title":"Selector","text":"<p>{ align=left }</p> <p>L'objetif ici est le suivant, dans un premeier temps nous allons verifier que nous avons pas deja un goal en attente, si c'est la cas on peut aller generer la trajectoire pour atteindre notre goal. En revanche si nous avons pas de goal present alors nous pouvons rester en attente de goal avant de poursuivre </p> <pre><code>##############################################################################\n# Imports\n##############################################################################\nimport functools\nimport py_trees\nimport py_trees_ros\nimport py_trees.console as console+-\nimport rospy\nimport sys\nfrom geometry_msgs.msg import PoseStamped\nimport geometry_msgs.msg as geometry_msgs\nimport mbf_msgs.msg as mbf_msgs\n##############################################################################\n# Actions\n##############################################################################\nclass GetPath(py_trees_ros.actions.ActionClient):\ndef initialise(self):\nself.action_goal = mbf_msgs.GetPathGoal(target_pose=py_trees.blackboard.Blackboard().get(\"target_pose\"))\nsuper(GetPath, self).initialise()\ndef update(self):\nstatus = super(GetPath, self).update()\nif status == py_trees.Status.SUCCESS:\npy_trees.blackboard.Blackboard().set(\"path\", self.action_client.get_result().path)\nreturn status\nclass ExePath(py_trees_ros.actions.ActionClient):\ndef initialise(self):\nself.action_goal = mbf_msgs.ExePathGoal(path=py_trees.blackboard.Blackboard().get(\"path\"))\nsuper(ExePath, self).initialise()\n##############################################################################\n# Behaviours\n##############################################################################\ndef create_root():\n# Create all behaviours\nbt_root = py_trees.composites.Sequence(\"MBF BT Demo\")\nget_goal = py_trees.composites.Selector(\"GetGoal\")\nfallback = py_trees.composites.Selector(\"Fallback\")\nnavigate = py_trees.composites.Sequence(\"Navigate\")\nnew_goal = py_trees_ros.subscribers.ToBlackboard(name=\"NewGoal\",\ntopic_name=\"/move_base_simple/goal\",\ntopic_type=geometry_msgs.PoseStamped,\nblackboard_variables = {'target_pose': None})\nhave_goal = py_trees.blackboard.CheckBlackboardVariable(name=\"HaveGoal\", variable_name=\"target_pose\")\nclr_goal1 = py_trees.blackboard.ClearBlackboardVariable(name=\"ClearGoal\", variable_name=\"target_pose\")\nclr_goal2 = py_trees.blackboard.ClearBlackboardVariable(name=\"ClearGoal\", variable_name=\"target_pose\")\nget_path = GetPath(name=\"GetPath\",\naction_namespace=\"/move_base_flex/get_path\",\naction_spec=mbf_msgs.GetPathAction)\nexe_path = ExePath(name=\"ExePath\",\naction_namespace=\"/move_base_flex/exe_path\",\naction_spec=mbf_msgs.ExePathAction)\n# Compose tree\nbt_root.add_children([get_goal, fallback])\nget_goal.add_children([have_goal, new_goal])\nnavigate.add_children([get_path, exe_path,clr_goal1])\nfallback.add_children([navigate,clr_goal2 ])\nreturn bt_root\ndef shutdown(behaviour_tree):\nbehaviour_tree.interrupt()\nif __name__ == '__main__':\nrospy.init_node(\"mbf_bt_demo\")\nroot = create_root()\nbehaviour_tree = py_trees_ros.trees.BehaviourTree(root)\nrospy.on_shutdown(functools.partial(shutdown, behaviour_tree))\nif not behaviour_tree.setup(timeout=15):\nconsole.logerror(\"failed to setup the tree, aborting.\")\nsys.exit(1)\nbehaviour_tree.tick_tock(500)\n</code></pre> <p>niquzta elere deded</p>"},{"location":"MultiMachine/","title":"Communication Multimachine","text":"<p>En robotique il est souvent n\u00e9cessaire d'avoir plusieurs machines qui communiquent entre elles. Dans notre cas nous avons un robot mobile qui doit communiquer avec une console d\u00e9port\u00e9e</p> <p>Il existe plusieurs fa\u00e7ons de communiquer entre machines avec ROS</p> <p>Nous allons d\u00e9crire quelqu'une de ces m\u00e9thodes en pr\u00e9sentant leurs avantages et inconv\u00e9nients</p> <p>Dans toutes ces m\u00e9thodes des machines partage le m\u00eame r\u00e9seau. Pour que deux machines puissent communiquer correctement, il est important, dans /etc/hosts,  d'ajouter la ligne suivante:</p>"},{"location":"MultiMachine/#au-niveau-de-la-machine1","title":"Au niveau de la machine1","text":"<pre><code>[IP machinne 1]    [Nom machinne 1]\n</code></pre> <p>exemple:</p> <pre><code>192.168.1.4     robot\n</code></pre>"},{"location":"MultiMachine/#au-niveau-de-la-machine2","title":"Au niveau de la machine2","text":"<pre><code>[IP machinne 2]    [Nom machinne 2]\n</code></pre> <p>exemple:</p> <pre><code>192.168.1.5     console\n</code></pre>"},{"location":"MultiMachine/#1-utilisation-dune-machine-maitre","title":"1. Utilisation d'une machine \"ma\u00eetre\"","text":"<p>La m\u00e9thode la plus simple et d'utiliser un master unique partag\u00e9 par plusieurs machines.</p> <p></p> <p>Nous avons une machine \"ma\u00eetre\" qui partage son master avec des machines \"escalves\".</p>"},{"location":"MultiMachine/#commande","title":"Commande:","text":"<p>Au niveau de la machine ma\u00eetre, dans un terminal:</p> <pre><code>export ROS_HOSTNAME={IP MAITRE}\nexport ROS_MASTER_URI=http://{IP MAITRE}:11311\n</code></pre> <p>Au niveau de la machine esclave, dans un terminal:</p> <pre><code>export ROS_HOSTNAME={IP ESCLAVE}\nexport ROS_MASTER_URI=http://{IP MAITRE}:11311\n</code></pre>"},{"location":"MultiMachine/#exemple","title":"Exemple:","text":"<p>Prenons un exemple, nous avons deux machine, un robot et une console, d'adresse IP respective suivante : 192.168.1.1 et 192.168.1.2 </p> <p></p> <p>Ici, on utilise le master de la console.</p> <p>Au niveau de la console, dans un terminal:</p> <pre><code>export ROS_HOSTNAME=192.168.1.1\nexport ROS_MASTER_URI=http://192.168.1.1:11311\n</code></pre> <p>Au niveau du robot, dans un terminal:</p> <pre><code>export ROS_HOSTNAME=192.168.1.2\nexport ROS_MASTER_URI=http://192.168.1.1:11311\n</code></pre> <p>Ainsi les deux machines partage le m\u00eame master et peuvent donc echanger des topics.</p>"},{"location":"MultiMachine/#avantage","title":"Avantage","text":"<p>Cette m\u00e9thode et simple et rapide \u00e0 mettre en place.</p>"},{"location":"MultiMachine/#inconveniants","title":"Inconveniants","text":"<p>Le probl\u00e8me est l'ulisation d'un master unique. En effet si une machine \"esclave\" pert la connection avec la machine \"ma\u00eetre\" alors elle pert le master et ne peut donc plus utiliser les nodes ROS. Dans notre cas si le robot s'eloigne de notre console est se deconnecte alors il ne pourra plus utiliser ROS.</p>"},{"location":"MultiMachine/#2-utilisation-de-la-classe-c-rosmaster","title":"2. Utilisation de la classe c++ ros::master","text":"<p>Cette m\u00e9thode plus compliqu\u00e9 mais elle permet d'utiliser plusieurs master. Pour cela une machine se connecte au master d'une machine \"cible\" souscrit a un topic et publie une copie de ce m\u00eame topic dans son environement local (master local)</p> <p>Il existe une methode de la classe ros,  <code>ros::master::init()</code>  qui peremt de se connecte \u00e0 un autre master dans le m\u00eame reseau.</p> <p>Attention, pour utiliser cette m\u00e9thode il important d'ajouter au niveau de chaque machine dans <code>/etc/hosts</code> les adresses IP des autres machines</p>"},{"location":"MultiMachine/#exemple-de-code","title":"Exemple de code :","text":"<p>dans le code suivant une console se connecte au master d'un robot, souscirt a son topic SCAN et publie une copie de ce topic dans son environnement local.</p> <pre><code>int main(int argc, char **argv)\n{\n// On initialse notre node scan_copieur dans l'environnement local\nros::init(argc,argv,\"scan_copieur\");\nros::NodeHandle nh;\n// on cr\u00e9er un objet de notre classe PublisherLocal, on appel ainsi le constructeur qui cr\u00e9\u00e9 un publisher local\nPublisherLocal PublisherLocal;\n//On declare les deux environemments\nstd::string robot_master = \"http://192.168.1.4::11311\";\nstd::string console_master= \"http://192.168.1.5::11311\";\n//On cr\u00e9e une varibale map M_string et on insere \u00e0 l'index __master le master auquel on veux se connecter\nros::M_string remappings; remappings[\"__master\"] = robot_master;\n//On se connecte au master souhait\u00e9\nros::master::init(remappings);\n//On souscrit au topic Scan, ici on souscrit dans l'environnement du robot_master\nros::Subscriber subscriberFeedback = nh.subscribe(\"/scan\", 1000, &amp;PublisherLocal::callback, &amp;hostTopic);  [....]\n}\nclass PublisherLocal{\npublic:\nPublisherLocal();\n~PublisherLocal();\nvoid callback(const sensor_msgs::LaserScan msg);    ros::Publisher pub;\nprivate:\nros::NodeHandle n;\n};\nPublisherLocal::PublisherLocal() {\npub = n.advertise&lt;sensor_msgs::LaserScan&gt;(\"/scan\", 1000);\n}\nPublisherLocal::~PublisherLocal(){}\nvoid PublisherLocal::callback(const sensor_msgs::LaserScan msg){ if(ok == 1){\noldSeq = msg.header.seq;\nok = 0;\n}\nelse{\nnewSeq = msg.header.seq;\nok = 1;\n}\nif(newSeq &gt; oldSeq)\npub.publish(msg);\n}\n</code></pre> <p>Voir code complet -&gt; [lien git hub]</p>"},{"location":"MultiMachine/#avantage_1","title":"Avantage","text":"<p>Cette m\u00e9thode permet d'avoir plus de contr\u00f4les sur la connexion entre machines, elle rend la communication plus flexible. Chaque machine garde son propre master et peut donc \u00eatre ind\u00e9pendante de la connexion r\u00e9seau.</p>"},{"location":"MultiMachine/#inconveniants_1","title":"Inconveniants","text":"<p>La m\u00e9thode est plus complexe et est unidirectionnelle, en effet dans l'exemple pr\u00e9sent\u00e9 pr\u00e9c\u00e9demment, il s'agit d'une lecture et recopie mais pas d'un r\u00e9el \u00e9change de topic.</p> <p>Si plusieurs topics doivent \u00eatre \u00e9chang\u00e9s, il devient fastidieux de r\u00e9aliser une recopie pour chaque topic.</p>"},{"location":"MultiMachine/#3-utilisation-de-ros-bridge","title":"3. Utilisation de ROS Bridge","text":"<p>Dans l'exemple suivant nous allons utilis\u00e9 ROS2. L'avantage de ROS2 est que la communication se fait sans Master. Nous allons utliser ROS 2 pour transferer les topic d'une machine ROS1 \u00e0 une autre machine ROS1</p> <p></p>"},{"location":"MultiMachine/#au-niveau-de-la-machine-1","title":"Au niveau de la machine 1","text":"<pre><code>export ROS_MASTER_URI=http://192.168.1.4:11311\nexport ROS_HOSTNAME=192.168.1.4\n</code></pre>"},{"location":"MultiMachine/#au-niveau-de-la-machine-2","title":"Au niveau de la machine 2","text":"<p>Premier terminal</p> <pre><code>export ROS_MASTER_URI=http://192.168.1.4:11311\nsource ROS1\nsource ROS2\nros2 run ros1_bridge dynamic_bridge --bridge-all-topics\n</code></pre> <p>Deuxi\u00e8me terminal</p> <pre><code>source ROS1\nsource ROS2\nros2 run ros1_bridge dynamic_bridge --bridge-all-topics\n</code></pre> <p>Ce script .sh permet d'automatiser la connection</p> <pre><code>export ROS_MASTER_URI=http://192.168.1.4:11311\nsource ${ROS1}\nsource ${ROS2}\ngnome-terminal --tab --command=\"ros2 run ros1_bridge dynamic_bridge --bridge-all-topics\"\nexport ROS_MASTER_URI=http://localhost:11311\n\nsource ${ROS1}\nsource ${ROS2}\ngnome-terminal --tab --command=\"ros2 run ros1_bridge dynamic_bridge --bridge-all-topics\"\nsource ${ROS1}\nsource devel/setup.bash\nroslaunch nodes starting_launch.launch #lancement d'un node dans ROS1 local\n</code></pre>"},{"location":"Nav/","title":"Move base Flex","text":"<p>Move_base_flex est un composant ROS (Robot Operating System) utilis\u00e9 pour la planification de la navigation autonome dans un environnement de robot. Il fournit une solution pour la planification de la navigation autonome en utilisant des algorithmes de planification de la trajectoire et de la gestion de la carte de co\u00fbts.</p> <p></p> <p>MoveBaseFlex est une extension de la biblioth\u00e8que de navigation de base de ROS (Robot Operating System), qui est \u00e9galement appel\u00e9e MoveBase. MoveBaseFlex h\u00e9rite du fonctionnement de base de MoveBase, mais ajoute des fonctionnalit\u00e9s suppl\u00e9mentaires pour prendre en charge diff\u00e9rents algorithmes de planification et de suivi de chemin pour les robots mobiles.</p> <p>MoveBaseFlex est con\u00e7u pour \u00eatre plus flexible que MoveBase et peut \u00eatre utilis\u00e9 pour des sc\u00e9narios de navigation plus complexes. Il permet de changer facilement les algorithmes de planification et de suivi de chemin en fonction des besoins sp\u00e9cifiques de l'application, sans avoir \u00e0 modifier le code source.</p> <p>Voir -&gt; Documentation Move_Base_Flex</p> <p>Pour realiser une navigation flexible est adpat\u00e9 a notre besoin nous allons nous ajouter nos propre plugin qui vont ensuite \u00eatre appeler par les serveur move_base_flex</p> <p></p>"},{"location":"Nav/#global-costmap","title":"Global Costmap","text":"<p>La carte fournie par un Lidar ezst utulis\u00e9 par le Global Costmap. Le co\u00fbt associ\u00e9 \u00e0 chaque pixel de la carte est d\u00e9termin\u00e9 par la planification de chemin et l'\u00e9vitement d'obstacles. Plus pr\u00e9cis\u00e9ment, le Global Costmap utilise des donn\u00e9es de capteurs pour d\u00e9tecter les obstacles et les ajouter \u00e0 la carte, en assignant un co\u00fbt \u00e9lev\u00e9 \u00e0 ces zones pour indiquer aux algorithmes de planification de chemin qu'il est pr\u00e9f\u00e9rable de les \u00e9viter. Le Global Costmap est utilis\u00e9 pour g\u00e9n\u00e9rer des chemins s\u00fbrs pour le robot en fonction de son environnement actuel.</p> <p>Le Global Costmap est une carte \u00e0 grande \u00e9chelle qui repr\u00e9sente l'environnement dans son ensemble, en incluant des obstacles d\u00e9termin\u00e9s par les capteurs du robot. Cette carte est utilis\u00e9e pour planifier des chemins \u00e0 long terme pour le robot en \u00e9vitant les obstacles.</p> <p></p> Param\u00e8tre Valeur <code>global_frame</code> <code>map</code> <code>robot_base_frame</code> <code>base_footprint</code> <code>update_frequency</code> <code>10.0</code> <code>publish_frequency</code> <code>10.0</code> <code>transform_tolerance</code> <code>10</code> <code>static_map</code> <code>true</code> <code>latch_xy_goal_tolerance</code> <code>false</code> <code>inflation_radius</code> <code>0.35</code> <code>cost_scaling_factor</code> <code>0.1</code>"},{"location":"Nav/#local-costmap","title":"Local Costmap","text":"<p>Le local_costmap est une partie du syst\u00e8me de navigation ROS qui permet \u00e0 un robot de construire et maintenir une carte locale de son environnement imm\u00e9diat. Ce local_costmap utilise souvent des donn\u00e9es provenant d'un capteur LiDAR (ou Laser Detection and Ranging) pour mesurer la distance aux obstacles dans son environnement. Les donn\u00e9es du LiDAR sont utilis\u00e9es pour cr\u00e9er une carte 2D de la r\u00e9gion environnante, o\u00f9 chaque pixel repr\u00e9sente la distance \u00e0 un obstacle ou un espace libre. Cette carte est ensuite utilis\u00e9e par l'algorithme de navigation pour planifier un chemin de mani\u00e8re \u00e0 \u00e9viter les obstacles.</p> <p>Le local_costmap est g\u00e9n\u00e9ralement d\u00e9fini avec un certain nombre de param\u00e8tres, tels que la fr\u00e9quence de mise \u00e0 jour, la taille de la fen\u00eatre roulante, la r\u00e9solution, l'inflation des obstacles, etc. qui d\u00e9terminent comment les donn\u00e9es du LiDAR sont utilis\u00e9es pour construire et maintenir la carte locale. En g\u00e9n\u00e9ral, l'objectif est de fournir une repr\u00e9sentation pr\u00e9cise et \u00e0 jour de l'environnement du robot pour aider \u00e0 la planification de son chemin de mani\u00e8re s\u00fbre et efficace.</p> Param\u00e8tre Valeur <code>global_frame</code> <code>odom</code> <code>robot_base_frame</code> <code>base_footprint</code> <code>update_frequency</code> <code>10.0</code> <code>publish_frequency</code> <code>10.0</code> <code>transform_tolerance</code> <code>10</code> <code>rolling_window</code> <code>true</code> <code>width</code> <code>3</code> <code>height</code> <code>3</code> <code>resolution</code> <code>0.05</code> <code>latch_xy_goal_tolerance</code> <code>false</code> <code>inflation_radius</code> <code>0.2</code> <code>cost_scaling_factor</code> <code>0.2</code>"},{"location":"Nav/#global-planner","title":"Global Planner","text":"<p>Le Global Planner est responsable de la planification du chemin global pour un robot mobile pour aller d'un point de d\u00e9part \u00e0 un point d'arriv\u00e9e. Il utilise une carte de co\u00fbt pour \u00e9valuer les diff\u00e9rents chemins possibles et en d\u00e9duire le plus optimal. Il peut utiliser des algorithmes de planification de chemin tels que l'algorithme A * ou Dijkstra pour trouver le chemin optimal. Le Global Planner est g\u00e9n\u00e9ralement utilis\u00e9 en conjonction avec le Local Planner pour former un syst\u00e8me complet de navigation pour les robots mobiles.</p> <p>Voir -&gt; Documentation Global Planner</p> <p>Ce plugin peut etre appeler en utilisant le service /make plan ou grace \u00e0 l'action /get_path</p>"},{"location":"Nav/#action-get_path","title":"Action /get_path","text":"<p>Voici un exemple de code Python qui souscrit au topic /move_base_simple/goal et publie la cible dans l'action /get_path</p> <pre><code>import rospy\nimport actionlib\nfrom geometry_msgs.msg import PoseStamped\nfrom move_base_msgs.msg import GetPathAction, GetPathGoal\nclass MoveBaseFlex:\ndef __init__(self):\nself.sub = rospy.Subscriber(\"/move_base_simple/goal\", PoseStamped, self.callback)\nself.client = actionlib.SimpleActionClient('move_base_flex/get_path', GetPathAction)\ndef callback(self, msg):\nself.client.wait_for_server()\ngoal = GetPathGoal()\ngoal.target_pose = msg\nself.client.send_goal(goal)\nif __name__ == '__main__':\nrospy.init_node('move_base_flex_node')\nmbf = MoveBaseFlex()\nrospy.spin()\n</code></pre> <p>Dans le Global Planner de ROS, le \"cost_factor\" (facteur de co\u00fbt) est un param\u00e8tre qui d\u00e9termine le niveau de pond\u00e9ration des co\u00fbts associ\u00e9s \u00e0 chaque cellule de la \"costmap\". Il s'agit d'un nombre \u00e0 virgule flottant avec une valeur par d\u00e9faut de 3.0. Il peut influencer le comportement du planificateur en termes de pr\u00e9f\u00e9rence pour certain pixels sur la carte.</p> <p></p> <p>Le cost_factor indique \u00e0 quel point une cellule sera \u00e9vit\u00e9e par le planificateur de chemin durant la planification de la trajectoire pour atteindre la destination souhait\u00e9e.</p> <p>Un co\u00fbt facteur \u00e9lev\u00e9 indique que la cellule est consid\u00e9r\u00e9e comme difficile \u00e0 traverser et sera donc \u00e9vit\u00e9e par le planificateur de chemin. Inversement, un co\u00fbt facteur faible indique que la cellule est consid\u00e9r\u00e9e comme facile \u00e0 traverser et sera donc favoris\u00e9e par le planificateur de chemin.</p> <p>Attention de si le cost_factor est trop faible, il risque de cr\u00e9er des paths erron\u00e9es:  Ci-dessus avec un costMap de 0.1, la path gener\u00e9 ne d\u00e9bute pas au niveau du robot</p> <pre><code>source devel/setup.bash\nexport TURTLEBOT3_MODEL=rescue\nroslaunch turtlebot3_gazebo turtlebot3_world.launch\n</code></pre>"},{"location":"Nav/#_1","title":"Move_Base_Flex","text":"<pre><code>source devel/setup.bash\nexport TURTLEBOT3_MODEL=rescue\nroslaunch mbf_advanced amcl_demo_mbf_recovery.launch\n</code></pre>"},{"location":"Nav/#_2","title":"Move_Base_Flex","text":"<pre><code>source devel/setup.bash\nrosrun mbf_advanced pytreesRecovery.py\n</code></pre>"},{"location":"Nav/#_3","title":"Move_Base_Flex","text":"<pre><code>rosrun rqt_py_trees rqt_py_trees\n</code></pre>"},{"location":"Nav/#move-base-client","title":"Move base Client","text":"<p>Le launch file suivant lance  \"move_base_flex\". Ce noeud appartient au package \"mbf_costmap_nav\" et utilise le type \"mbf_costmap_nav\".</p> <p>Le noeud charge plusieurs fichiers de param\u00e8tres ROS \u00e0 l'aide de la commande \"rosparam\". Les fichiers de param\u00e8tres d\u00e9finissent les comportements du noeud \"move_base_flex\", tels que les param\u00e8tres de co\u00fbts pour les cartes locales et globales de l'environnement ainsi que les param\u00e8tres de planification de la base locale. Les param\u00e8tres de r\u00e9cup\u00e9ration \"move_base_flex_recovery\" sont \u00e9galement charg\u00e9s pour d\u00e9finir les comportements de r\u00e9cup\u00e9ration.</p> <pre><code>  &lt;node name=\"move_base_flex\" pkg=\"mbf_costmap_nav\" type=\"mbf_costmap_nav\" required=\"true\" output=\"screen\" clear_params=\"true\"&gt;\n&lt;rosparam file=\"$(find mbf_advanced)/param/move_base_classic/costmap_common_params_$(arg model).yaml\" command=\"load\" ns=\"global_costmap\" /&gt;\n&lt;rosparam file=\"$(find mbf_advanced)/param/move_base_classic/costmap_common_params_$(arg model).yaml\" command=\"load\" ns=\"local_costmap\" /&gt;\n&lt;rosparam file=\"$(find mbf_advanced)/param/move_base_classic/local_costmap_params.yaml\" command=\"load\" /&gt;\n&lt;rosparam file=\"$(find mbf_advanced)/param/move_base_classic/global_costmap_params.yaml\" command=\"load\" /&gt;\n&lt;rosparam file=\"$(find mbf_advanced)/param/move_base_flex_recovery.yaml\" command=\"load\"/&gt;\n&lt;rosparam file=\"$(find mbf_advanced)/param/move_base_classic/base_local_planner_params.yaml\" command=\"load\" /&gt;\n&lt;/node&gt;\n</code></pre> <p>Nous incluons les different param\u00e8tre necessaire pour parametre nos plugins</p> <p>La premiere etape et de se soscrire au topic poseStamped qui peremt d'envyer un goal et d'envoyer ce goal a move base en utilisant les action de action lib</p> <pre><code>#!/usr/bin/env python\nimport actionlib\nimport rospy\nimport nav_msgs.srv as nav_srvs\nimport mbf_msgs.msg as mbf_msgs\nimport move_base_msgs.msg as mb_msgs\nfrom geometry_msgs.msg import PoseStamped\ndef simple_goal_cb(msg):\nmbf_mb_ac.send_goal(mbf_msgs.MoveBaseGoal(target_pose=msg))\nrospy.logdebug(\"Relaying move_base_simple/goal pose to mbf\")\nmbf_mb_ac.wait_for_result()\nstatus = mbf_mb_ac.get_state()\nresult = mbf_mb_ac.get_result()\nrospy.logdebug(\"MBF execution completed with result [%d]: %s\", result.outcome, result.message)\nif __name__ == '__main__':\nrospy.init_node(\"move_base_relay\")\n# move base flex ation client relays incoming mb goals to mbf\nmbf_mb_ac = actionlib.SimpleActionClient(\"move_base_flex/move_base\", mbf_msgs.MoveBaseAction)\nmbf_mb_ac.wait_for_server(rospy.Duration(20))\n# move_base simple topic and action server\nmb_sg = rospy.Subscriber('move_base_simple/goal', PoseStamped, simple_goal_cb)\nrospy.on_shutdown(lambda: mbf_mb_ac.cancel_all_goals())\nrospy.spin()sd\n</code></pre> <p>Explication du code:</p> <pre><code>mb_sg = rospy.Subscriber('move_base_simple/goal', PoseStamped, simple_goal_cb)\n</code></pre> <p>On cr\u00e9er un subsciber \"mb_sb\" qui souscit au topic \"move_base_simple/goal\" de type PoseStamped dont le CallBack et la fonction simple_goal_cb</p> <pre><code>mbf_mb_ac = actionlib.SimpleActionClient(\"move_base_flex/move_base\", mbf_msgs.MoveBaseAction)\nmbf_mb_ac.wait_for_server(rospy.Duration(20))\n</code></pre> <p>On instancit un client mbf_mb_ac  qui va se connecter au node (serveur) /move_base_flex  avec commme action : /move_base_flex/move_base</p> <p>Le node move_base_flex dispose de plusieur action (fichier source dans /move_base_flex/mbf_abstract_nav/src/move_base_action.cpp)</p> <p>Whatch py_tree doc http://docs.ros.org/en/kinetic/api/py_trees_ros/html/tutorials.html</p>"},{"location":"Plugins/","title":"URDF","text":"<pre><code>&lt;?xml version=\"1.0\" ?&gt;\n&lt;robot name=\"turtlebot3_burger\" xmlns:xacro=\"http://ros.org/wiki/xacro\"&gt;\n&lt;xacro:include filename=\"$(find turtlebot3_description)/urdf/common_properties.xacro\"/&gt;\n&lt;xacro:include filename=\"$(find turtlebot3_description)/urdf/turtlebot3_burger.gazebo.xacro\"/&gt;\n</code></pre> <p>Le premier, common_properties.xacro permet de definir la couleur des links utilis\u00e9 en code RGB</p> <p>Le deuxieme, turtlebot3_burger.gazebo.xacro, contient les param\u00e8tres physiques appliqu\u00e9 \u00e0 nos joint comme le frotement ou l\u2019inertie et des plugin utilis\u00e9 lors de la simulation.</p>"},{"location":"Plugins/#plugins","title":"Plugins","text":"<ul> <li>turtlebot3_burger_controller</li> </ul> <p>Il permet de contr\u00f4ler le robot en publiant dasn un topic et de generer une odom\u00e9trie</p> <pre><code>&lt;gazebo&gt;\n&lt;plugin name=\"turtlebot3_burger_controller\" filename=\"libgazebo_ros_diff_drive.so\"&gt;\n&lt;commandTopic&gt;cmd_vel&lt;/commandTopic&gt;\n&lt;odometryTopic&gt;odom&lt;/odometryTopic&gt;\n&lt;odometryFrame&gt;odom&lt;/odometryFrame&gt;\n&lt;odometrySource&gt;world&lt;/odometrySource&gt;\n&lt;publishOdomTF&gt;true&lt;/publishOdomTF&gt;\n&lt;robotBaseFrame&gt;base_footprint&lt;/robotBaseFrame&gt;\n&lt;publishWheelTF&gt;false&lt;/publishWheelTF&gt;\n&lt;publishTf&gt;true&lt;/publishTf&gt;\n&lt;publishWheelJointState&gt;true&lt;/publishWheelJointState&gt;\n&lt;legacyMode&gt;false&lt;/legacyMode&gt;\n&lt;updateRate&gt;30&lt;/updateRate&gt;\n&lt;leftJoint&gt;wheel_left_joint&lt;/leftJoint&gt;\n&lt;rightJoint&gt;wheel_right_joint&lt;/rightJoint&gt;\n&lt;wheelSeparation&gt;0.160&lt;/wheelSeparation&gt;\n&lt;wheelDiameter&gt;0.066&lt;/wheelDiameter&gt;\n&lt;wheelAcceleration&gt;1&lt;/wheelAcceleration&gt;\n&lt;wheelTorque&gt;10&lt;/wheelTorque&gt;\n&lt;rosDebugLevel&gt;na&lt;/rosDebugLevel&gt;\n&lt;/plugin&gt;\n&lt;/gazebo&gt;\n</code></pre> <p>Ici nous pouvons controler le robot en publiant dans \u201ccmd_vel\u201d, le topic odom\u00e9trie et \u201codom\u201d et la transformation ce fait entre \u201codom\u201d et \u201cbase_footprint\u201d</p> <ul> <li>gazebo_ros_lds_lfcd_controller</li> </ul> <p>Ce plugin  permet de simuler un lidar: </p> <pre><code> &lt;plugin name=\"gazebo_ros_lds_lfcd_controller\" filename=\"libgazebo_ros_laser.so\"&gt;\n&lt;topicName&gt;scan&lt;/topicName&gt;\n&lt;frameName&gt;base_scan&lt;/frameName&gt;\n&lt;/plugin&gt;\n</code></pre> <p>Il gen\u00e8re un topic \u201cscan\u201d dont le nom est definti dans TopicName,  le scan ce fait dans le plan definti par le link frameName ici,  \u201cbase-scan\u201d.</p>"},{"location":"Recovery/","title":"Recovery","text":"<p>Le paquet move_base_flex de ROS utilise un syst\u00e8me de plugins pour permettre la s\u00e9lection de diff\u00e9rents comportements de navigation en fonction des conditions du terrain et des capacit\u00e9s du robot.</p> <p>Parmi les plugins disponibles, il y a un plugin de recovery qui est utilis\u00e9 pour g\u00e9rer les cas d'\u00e9chec de navigation, tels que les blocages, les collisions et les erreurs de planification. Ce plugin est appel\u00e9 lorsqu'un \u00e9chec de navigation est d\u00e9tect\u00e9 pour permettre au robot de se remettre sur la bonne voie et de continuer \u00e0 atteindre son objectif.</p> <p>Pour appeler le plugin de recovery, la fonction move_base_flex utilise la fonction ROS \"recover\" qui est d\u00e9finie dans le paquet move_base. Cette fonction est appel\u00e9e lorsqu'un \u00e9chec de navigation est d\u00e9tect\u00e9, et elle utilise la liste de plugins de recovery configur\u00e9e pour s\u00e9lectionner le plugin appropri\u00e9 \u00e0 utiliser pour r\u00e9soudre l'\u00e9chec.</p> <p>Le syst\u00e8me de r\u00e9cup\u00e9ration de MBF est con\u00e7u pour \u00eatre flexible et extensible, de sorte que de nouveaux comportements de r\u00e9cup\u00e9ration peuvent \u00eatre facilement ajout\u00e9s ou modifi\u00e9s pour r\u00e9pondre aux besoins de diff\u00e9rents environnements de navigation.</p> <p>dans move_base_flex_recovery.yaml nous ajoutons les plugins que l'on shoaie utiliser</p> <pre><code>planners:\n- name: navfn/NavfnROS\ntype: navfn/NavfnROS\n- name: global_planner/GlobalPlanner\ntype: global_planner/GlobalPlanner\ncontrollers:\n- name: dwa_local_planner/DWAPlannerROS\ntype: dwa_local_planner/DWAPlannerROS\n#- name: eband_local_planner/EBandPlannerROS\n#  type: eband_local_planner/EBandPlannerROS\n# - name: teb_local_planner/TebLocalPlannerROS\n#   type: teb_local_planner/TebLocalPlannerROS\nrecovery_behaviors:\n- name: 'rotate_recovery/RotateRecovery'\ntype: 'rotate_recovery/RotateRecovery'\n- name: clear_costmap_recovery\ntype: clear_costmap_recovery/ClearCostmapRecovery\n- name: 'moveback_recovery'\ntype: 'moveback_recovery/MoveBackRecovery'\nmoveback_recovery:\nlinear_vel_back: -0.4 # default -0.3\nstep_back_length: 0.3  # default 1.0\nstep_back_timeout: 5.0 # default 15.0\ncontroller_frequency: 5.0\ncontroller_patience: 10.0\ncontroller_max_retries: 10\nplanner_frequency: 1\nplanner_patience: 10.0\nplanner_max_retries: 10\nrecovery_enabled: true\nrecovery_patience: 15.0\noscillation_timeout: 10.0\noscillation_distance: 0.2\n</code></pre>"},{"location":"Recovery/#rotate-recovery","title":"Rotate Recovery","text":"<p>Le plugin  <code>rotate_recovery/RotateRecovery</code> est un plugin custum -&gt; Cr\u00e9er son propre plugin qui met en roation le robot et s'arreter lorsqu'il est align\u00e9 avec la trajectoire</p> <p></p> <p>Lors d'une rotation le robot s'arrette si il detecte un obstacle et revoi le code  159  [CANT_TURN]</p> <p></p>"},{"location":"Recovery/#move-back-recovery","title":"Move Back Recovery","text":"<p>Ce Recovery fait reculer le robot a une distance et avec une vitesse definit</p> <p></p> <p>Le robot s'arrette si il detecte un obstacle et revoi le code  150  [FAILURE]</p> <p></p>"},{"location":"Recovery_Plugin/","title":"Plugin Custum","text":"<p>La classe CostmapRecovery d\u00e9finit une interface pour les comportements de r\u00e9cup\u00e9ration utilis\u00e9s dans la navigation. Elle h\u00e9rite de la classe mbf_abstract_core::AbstractRecovery et doit \u00eatre impl\u00e9ment\u00e9e par tous plugins de r\u00e9cup\u00e9ration qui souhaite \u00eatre utilis\u00e9 dans le syst\u00e8me de navigation MBF.</p> <p>La classe CostmapRecovery</p> <pre><code>#ifndef MBF_COSTMAP_CORE__COSTMAP_RECOVERY_H_\n#define MBF_COSTMAP_CORE__COSTMAP_RECOVERY_H_\n#include &lt;mbf_abstract_core/abstract_recovery.h&gt;\n#include &lt;costmap_2d/costmap_2d_ros.h&gt;\n#include &lt;mbf_utility/types.h&gt;\nnamespace mbf_costmap_core\n{\n/**\n* @class CostmapRecovery\n* @brief Provides an interface for recovery behaviors used in navigation.\n* All recovery behaviors written to work as MBF plugins must adhere to this interface. Alternatively, this\n* class can also operate as a wrapper for old API nav_corebased plugins, providing backward compatibility.\n*/\nclass CostmapRecovery : public mbf_abstract_core::AbstractRecovery{\npublic:\ntypedef boost::shared_ptr&lt; ::mbf_costmap_core::CostmapRecovery&gt; Ptr;\n/**\n  * @brief Initialization function for the CostmapRecovery\n  * @param tf A pointer to a transform listener\n  * @param global_costmap A pointer to the global_costmap used by the navigation stack\n  * @param local_costmap A pointer to the local_costmap used by the navigation stack\n  */\nvirtual void initialize(std::string name, TF* tf,\ncostmap_2d::Costmap2DROS* global_costmap,\ncostmap_2d::Costmap2DROS* local_costmap) = 0;\n/**\n  * @brief Runs the CostmapRecovery\n  * @param message The recovery behavior could set, the message should correspond to the return value\n  * @return An outcome which will be hand over to the action result.\n  */\nvirtual uint32_t runBehavior(std::string&amp; message) = 0;\n/**\n  * @brief Requests the planner to cancel, e.g. if it takes too much time\n  * @remark New on MBF API\n  * @return True if a cancel has been successfully requested, false if not implemented.\n  */\nvirtual bool cancel() = 0;\n/**\n  * @brief Virtual destructor for the interface\n  */\nvirtual ~CostmapRecovery(){}\nprotected:\nCostmapRecovery(){}\n};\n}  /* namespace mbf_costmap_core */\n#endif /* MBF_COSTMAP_CORE__COSTMAP_RECOVERY_H_ */\n</code></pre> <p>La classe d\u00e9finit les m\u00e9thodes virtuelles suivantes :</p> <ul> <li> <p>initialize : fonction d'initialisation pour la r\u00e9cup\u00e9ration des co\u00fbts. Elle prend en entr\u00e9e un nom, un pointeur sur un \u00e9couteur de transformation, un pointeur sur la carte de co\u00fbts globale utilis\u00e9e par la pile de navigation et un pointeur sur la carte de co\u00fbts locale utilis\u00e9e par la pile de navigation.</p> </li> <li> <p>runBehavior : Ex\u00e9cute la r\u00e9cup\u00e9ration des co\u00fbts. La fonction prend en entr\u00e9e un message qui peut \u00eatre d\u00e9fini par le comportement de r\u00e9cup\u00e9ration, le message doit correspondre \u00e0 la valeur de retour. La fonction renvoie un code d'\u00e9tat qui sera transmis au r\u00e9sultat de l'action.</p> </li> <li> <p>cancel : demande au planificateur d'annuler, par exemple s'il prend trop de temps. La fonction retourne vrai si une annulation a \u00e9t\u00e9 demand\u00e9e avec succ\u00e8s, faux si elle n'est pas impl\u00e9ment\u00e9e.</p> </li> <li> <p>~CostmapRecovery : destructeur virtuel pour l'interface.</p> </li> </ul> <p>Les classes qui impl\u00e9mentent cette interface doivent d\u00e9finir les m\u00e9thodes initialize, runBehavior et \u00e9ventuellement cancel. La classe CostmapRecovery fournit \u00e9galement un type de pointeur partag\u00e9 pour faciliter la cr\u00e9ation d'instances de sous-classes.</p> <p>Nous allons cr\u00e9er un plugin que appeler rotate_recovery </p> <p>Notre classe doit h\u00e9riter de l\u2019interface mbf_costmap_core::CostmapRecovery</p> <pre><code>class RotateRecovery : public mbf_costmap_core::CostmapRecovery\n</code></pre> <p>Dans un premier temps on int\u00e9grer la library permettant d\u2019exporter notre plugin</p> <pre><code>#include &lt;pluginlib/class_list_macros.h&gt;\n</code></pre> <p>On exporte notre plugin et l\u2019inteface mbf_costmap_core::CostmapRecovery:</p> <pre><code>PLUGINLIB_EXPORT_CLASS(rotate_recovery::RotateRecovery, mbf_costmap_core::CostmapRecovery)\n</code></pre> <p>PLUGINLIB_EXPORT_CLASS est une macro utilis\u00e9e par la biblioth\u00e8que pluginlib pour exporter une classe en tant que plugin pour qu'elle puisse \u00eatre d\u00e9couverte et utilis\u00e9e par d'autres applications. La macro permet de d\u00e9finir la classe (ici rotate_recovery::RotateRecovery) en tant que plugin avec une classe de base (ici mbf_costmap_core::CostmapRecovery). Cela signifie que les applications qui souhaitent utiliser ce plugin pouront le faire en s'attendant \u00e0 une interface compatible avec la classe de base.</p> <p>Notre classe doit donc contenir les methode suivante :</p> <pre><code>virtual void initialize(std::string name, tf2_ros::Buffer*,\ncostmap_2d::Costmap2DROS*, costmap_2d::Costmap2DROS* local_costmap);\nvirtual uint32_t runBehavior(std::string&amp; message);\nvirtual bool cancel();\n~RotateRecovery();\n</code></pre> <p>Nous devons \u00e9galement cr\u00e9er un fichier XML pour enregistrer un plugin de comportement de r\u00e9cup\u00e9ration dans la biblioth\u00e8que de plugins ROS. Le plugin est d\u00e9fini par la classe \"rotate_recovery::RotateRecovery\" qui h\u00e9rite de la classe de base \"mbf_costmap_core::CostmapRecovery\". Le tag  sp\u00e9cifie le chemin de la biblioth\u00e8que dynamique \"librotate_recovery\" qui contient le plugin. Le tag  fournit des informations sur la classe, y compris son nom, son type et le type de sa classe de base. La description d\u00e9crira bri\u00e8vement ce que fait le comportement de r\u00e9cup\u00e9ration. <pre><code>&lt;library path=\"lib/librotate_recovery\"&gt;\n&lt;class name=\"rotate_recovery/RotateRecovery\" type=\"rotate_recovery::RotateRecovery\" base_class_type=\"mbf_costmap_core::CostmapRecovery\"&gt;\n&lt;description&gt;\nA recovery behavior that performs a 360 degree in-place rotation to attempt to clear out space.\n    &lt;/description&gt;\n&lt;/class&gt;\n&lt;/library&gt;\n</code></pre> <p>Le pacquet du plugin doit ressembler \u00e0 ca:</p> <p></p> <p>Dans le liens suivant le packet roate recovery complet:</p> <p>Rotate_recovery</p>"},{"location":"Setup/","title":"Setup","text":"<p>Cr\u00e9ations d\u2018un Workspace que nous allons appeler move_base_ws</p> <p>schema simplifier </p> <pre><code>mkdir moveBase_ws\ncd moveBase_ws\n</code></pre> <p>Cr\u00e9ation d\u2019un fichier source:</p> <pre><code>mkdir src\n</code></pre> <p>Dans source nous allons cr\u00e9er un fichier  allons appeler mvb_ws:</p> <pre><code>cd src\nmkdir mvb_pkg\n</code></pre> <p>nous allons copier dans notre package les fichier source de navigation</p> <pre><code>sudo git clone https://github.com/ros-planning/navigation.git\n</code></pre> <p>Il est \u00e9galement possible d\u2019installer les fichier source directement avec apt-get     XXXXX</p> <p>nous allons ajouter le paquet turtlebot 3 utilisants move_base</p> <pre><code>sudo git clone https://github.com/ROBOTIS-GIT/turtlebot3.git\n</code></pre> <p>Enfin nous allons cloner le paquet turtlebot permettant la simulation dans l'environnement 3d gazebo </p> <pre><code>sudo git clone https://github.com/ROBOTIS-GIT/turtlebot3_simulations.git\n</code></pre>"},{"location":"Sim/","title":"Launch File","text":"<p>Pour commencer nous allons lanver une simulation gazebo dans le monde trurtlebot word 3</p> <pre><code>    &lt;launch&gt;\n&lt;arg name=\"model\" default=\"$(env TURTLEBOT3_MODEL)\" doc=\"model type [burger, waffle, waffle_pi]\"/&gt;\n&lt;arg name=\"x_pos\" default=\"-2.0\"/&gt;\n&lt;arg name=\"y_pos\" default=\"-0.5\"/&gt;\n&lt;arg name=\"z_pos\" default=\"0.0\"/&gt;\n</code></pre> <p>Ici, le launch file attend un argument \u201cmodel\u201d qui nous laisse le choix entre different modele de robot  [burger, waffle, waffle_pi], ces mod\u00e8les sont present dans ls fichier models</p> <p>Les trois arguments suivatn x_pos, y_pos, et z_pos sont la position ou va apparaitre notre robot dans la map</p> <pre><code>  &lt;include file=\"$(find gazebo_ros)/launch/empty_world.launch\"&gt;\n&lt;arg name=\"world_name\" value=\"$(find turtlebot3_gazebo)/worlds/turtlebot3_world.world\"/&gt;\n&lt;arg name=\"paused\" value=\"false\"/&gt;\n&lt;arg name=\"use_sim_time\" value=\"true\"/&gt;\n&lt;arg name=\"gui\" value=\"true\"/&gt;\n&lt;arg name=\"headless\" value=\"false\"/&gt;\n&lt;arg name=\"debug\" value=\"false\"/&gt;\n&lt;/include&gt;\n</code></pre> <p>On inclu le launch file empty_word.launch qui va demarer une simulation, ce launch file prend plusieur argument d\u2019entr\u00e9e comme la map utilis\u00e9, \u201cword_name\u201d ici la valeur de notre argument va chercher un model monde present dans le fichier wordls. l\u2019agument \u201cgui\u201d mis a \u201ctrue\u201d permet de lancer l\u2019interface graphique de la simulation</p> <pre><code>    &lt;param name=\"robot_description\" command=\"$(find xacro)/xacro --inorder $(find turtlebot3_description)/urdf/turtlebot3_$(arg model).urdf.xacro\" /&gt;\n&lt;node pkg=\"gazebo_ros\" type=\"spawn_model\" name=\"spawn_urdf\"  args=\"-urdf -model turtlebot3_$(arg model) -x $(arg x_pos) -y $(arg y_pos) -z $(arg z_pos) -param robot_description\" /&gt;\n&lt;/launch&gt;\n</code></pre> <p>Nous lan\u00e7ons le node spawn_urdf du packet gazebo_ros qui prend comme parametre \u201crobot description\u201d , ce param\u00e8tre pointe vers l\u2019urdf de notre robot ici, si nous choisision le robot burger, l\u2019urdf sera : turtlebot3_burger.urdf.xacro</p> <p>Ce fichier se trouve dans turtlebo3/turtlebot3_description/urdf  , il est la description du robot au format URDF, dans l\u2019entete du fichier nous avons deux includes important:</p>"},{"location":"Sim/#lancement","title":"Lancement","text":"<p>Nous allons lancer la simulation:</p> <p>On choisi le mod\u00e8le du robot que l\u2019on souhaite parmis la liste suivant [burger, waffle, waffle_pi]</p> <pre><code>export TURTLEBOT3_MODEL=burger\n</code></pre> <p>On lance la simulation:</p> <pre><code>roslaunch turtlebot3_gazebo turtlebot3_world.launch\n</code></pre> <p>Voici le r\u00e9sultsat du gui Gazeo</p> <p></p>"},{"location":"TF/","title":"TF statique","text":"<p>Notre robot est compos\u00e9 de diff\u00e9rente corps ( flipper, roues, lidar ...) qui disposent chaqun de leur propre coordon\u00e9es. Pour visualiser notre robot dans l'espace il est necessaire de relier ces coorodn\u00e9es entre elles par le biai de transformation (TF).</p> <p>Dans notre cas, les diff\u00e9rents corps sont fixes les un des autres. Pour les relier on parle alors de TF statique. Pour r\u00e9aliser un TF statique nous pouvons utiliser le node robot_state_publisher et joint_state_publisher qui vont lire l'urdf de notre mod\u00e8le et creer les TF entre les different joints.</p>"},{"location":"TF/#launch-file","title":"Launch file","text":"<pre><code>&lt;launch&gt;\n&lt;arg name=\"model\" default=\"$(find rescue_description)/urdf/rescue.xacro\"/&gt;\n&lt;arg name=\"gui\" default=\"true\"/&gt;\n&lt;arg name=\"rvizconfig\" default=\"$(find rescue_description)/launch/urdf.rviz\"/&gt;\n&lt;param name=\"robot_description\" command=\"$(find xacro)/xacro $(arg model)\"/&gt;\n&lt;param name=\"use_gui\" value=\"$(arg gui)\"/&gt;\n&lt;node name=\"joint_state_publisher\" pkg=\"joint_state_publisher\" type=\"joint_state_publisher\"/&gt;\n&lt;node name=\"robot_state_publisher\" pkg=\"robot_state_publisher\" type=\"robot_state_publisher\"/&gt;\n&lt;node name=\"rviz\" pkg=\"rviz\" args=\"-d $(arg rvizconfig)\" type=\"rviz\" required=\"true\"/&gt;\n&lt;/launch&gt;\n</code></pre> <p>Lancement du launch file:</p> <pre><code>roslaunch rescue_description display.launch\n</code></pre> <p></p>"},{"location":"URDF/","title":"Mod\u00e8le","text":"<p>Un fichier URDF (Unified Robot Description Format) est un format de fichier XML utilis\u00e9 pour d\u00e9crire les diff\u00e9rentes parties d'un robot ainsi que leurs relations les unes avec les autres. Il d\u00e9finit les propri\u00e9t\u00e9s g\u00e9om\u00e9triques, dynamiques et s\u00e9mantiques d'un robot.</p> <p>Le fichier URDF est utilis\u00e9 pour cr\u00e9er un mod\u00e8le 3D du robot, qui peut \u00eatre visualis\u00e9 dans des outils de visualisation tels que RViz dans ROS (Robot Operating System). On utilise ce mod\u00e8le pour planifier les mouvements du robot, pour la simulation et pour la reconnaissance du monde environnant. Les informations sur les jointures, les moteurs, les capteurs, les liens et les jointures sont d\u00e9crites dans le fichier URDF.</p>"},{"location":"URDF/#corps","title":"Corps","text":"<p>Ci-dessous, les dimensions du corps du robot:</p> <p></p>"},{"location":"URDF/#collision","title":"Collision","text":"<p>On genere un rectangle correpondant au corps du robot:</p> <p>L\u2019origine du corps se trouve au centre du rectangle, on souhaite d\u00e9caler cette origine pour la placer au niveau de l\u2019entraxe des roues, on decale donc l\u2019axe x de 0.2 m</p> <p>Sur gazebo il est important de distingu\u00e9 deux param\u00e8tres de g\u00e9om\u00e9trie: Visual et colision. Une g\u00e9ometrie \u201ccollision\u201d elle aura des param\u00e8tre physique et sera donc soumis au frottement, friction, gravit\u00e9.. </p> <pre><code>&lt;collision&gt;\n&lt;origin xyz=\"0.2 0 0.0\" rpy=\"0 0 0\"/&gt;\n&lt;geometry&gt;\n&lt;box size=\"0.6 0.420 0.115\"/&gt;\n&lt;/geometry&gt;\n&lt;/collision&gt;\n</code></pre>"},{"location":"URDF/#visuel","title":"Visuel","text":"<p>Une g\u00e9ometrie \u201cvisual\u201d elle, sera purement visuel. Nous pouvons ajouter un mesh, un fichier 3D format STL que nous avons g\u00e9nerer avec un logicielle de CAO.</p> <pre><code>&lt;visual&gt;\n&lt;origin xyz=\"0.2 0 0.0\" rpy=\"0 0 -1.57\"/&gt;\n&lt;geometry&gt;\n&lt;mesh filename=\"package://rescue_description/meshes/base_link.stl\" scale=\"0.001 0.001 0.001\"/&gt;\n&lt;/geometry&gt;\n&lt;material name=\"light_black\"/&gt;\n&lt;/visual&gt;\n</code></pre>"},{"location":"URDF/#physique","title":"Physique","text":"<p>D\u00e9sormais nous devons definir l\u2019inertie de notre pi\u00e8ce. Notre corps est un rectangle, pour faciliter la t\u00e2che, nous pouvons inclure une macro qui calcul la matrice d\u2019inertie d\u2019un rectangle en fonction de sa masse et ses dimension. On y ajoute egalement l\u2019origine du corp.</p> <pre><code> &lt;xacro:macro name=\"box_inertia\" params=\"m w h d x y z\"&gt;\n&lt;inertial&gt;\n&lt;origin  xyz=\"${x} ${y} ${z}\"  rpy=\"${pi/2} 0 ${pi/2}\"/&gt;     &lt;mass value=\"${m}\"/&gt;\n&lt;inertia ixx=\"${(m/12) * (h*h + d*d)}\" ixy=\"0.0\" ixz=\"0.0\" iyy=\"${(m/12) * (w*w + d*d)}\" iyz=\"0.0\" izz=\"${(m/12) * (w*w + h*h)}\"/&gt;\n&lt;/inertial&gt;\n&lt;/xacro:macro&gt;\n</code></pre> <p>Nous pouvons appeler la macro dans la definiton du corps</p> <pre><code>&lt;xacro:box_inertia m=\"1O\" w=\"0.420\" d=\"0.6\" h=\"0.115\" x=\"0.2\" y=\"0\" z=\"0\" /&gt;\n</code></pre> <p></p>"},{"location":"URDF/#roue","title":"Roue","text":"<p>Les roues peuvent \u00eatre representer comme des cylindres. voici leur dimensions:</p> <p></p> <p>On cr\u00e9er un link que l\u2019on appelle Roue_Droite <pre><code>&lt;link name=\"Roue_Droite\"&gt;\n</code></pre></p> <p>On gen\u00e8re un cylindre avec les bonnes dimensions <pre><code>&lt;cylinder length=\"0.0375\" radius=\"0.050\"/&gt;        </code></pre></p> <p>On place l\u2019origine de la pi\u00e8ce en son centre: </p> <pre><code>&lt;origin xyz=\" 0 0 0\" rpy=\"0 0 0\"/&gt;\n</code></pre> <p></p> <p>Pour l'assembler au corps, nous devons cr\u00e9er le joint entre la roue droite et le corps du robot. </p> <pre><code>&lt;joint name=\"Joint_Roue_Droite\" type=\"continuous\"&gt;\n</code></pre> <p>Le joint est de type \"continuous\u201d pour indiquer une rotation autour d\u2019un axe unique</p> <p>On definit les lien de parent\u00e9:</p> <pre><code>&lt;parent link=\"base_link\"/&gt;\n&lt;child link=\"Roue_Droite\"/&gt;\n</code></pre> <p>on definit l\u2019origine du joint</p> <p>Cette origine est la distance entre les origines du link p\u00e8re et m\u00e8re en prenant comme origne fixe celle du p\u00e8re On Sohaite d\u00e9caler la roue par rapport \u00e0 l'origine du corps:</p> <p><pre><code> &lt;origin xyz=\"0 -0.21 -0.065\" rpy=\"0 0 0\"/&gt;\n</code></pre> </p> <p>On remarque que la roue n\u2019est pas orient\u00e9 correctement, il est necessaire de r\u00e9aliser une rotation de 90\u00b0 autour de l\u2019axe x</p> <p></p> <p>rotation de 90\u00b0 = \u03c0/2 = 1.57  autour de l\u2019axe x et decalage en y (epaisseur de la roue): <pre><code> &lt;origin xyz=\"0 -0.2285 -0.065\" rpy=\"-1.57 0 0\"/&gt;\n</code></pre></p> <p>Enfin , on definit l\u2019axe de rotation de notre roue, ici, l\u2019axe z <pre><code> &lt;axis xyz=\"0 0 1\"/&gt;\n</code></pre></p>"},{"location":"URDF/#footprint","title":"Footprint","text":"<p>Le footprint du robot definit l\u2019empreinte du robot dans l\u2019espace. Ce param\u00e8tre permet aux algorithme de navigation de connaitre les dimensions du robot. La d\u00e9limitation se d\u00e9finit en 4 point A,B,C,D</p> <pre><code> footprint: [[A], [B], [C], [D]]\n</code></pre> <p></p> <p>Nous devons choisir des points qui permettent de couvrir l\u2019integralit\u00e9 de l'espace pris par le robot L\u2019origine se base par rapport au base_link definit pr\u00e9c\u00e9demment. Dans l\u2019exemple ci-dessous nous avons represent\u00e9 les 4 points correspondant aux angle du corps du robot</p> <p>Le footprint correspondant est le suivant: <pre><code>footprint: [[-0.1,-0.21], [-0.1,0.21], [0.5,0.21], [0.5,-0.21]]\n</code></pre></p> <p>Pour couvrir le robot et ajouter une zone securit\u00e9 nous allons utilise\u00e9 un footprint l\u00e9g\u00e8rement plus grand:</p> <pre><code>footprint: [[-0.12,-0.23], [-0.12,0.23], [0.52,0.23], [0.52,-0.23]]\n</code></pre>"},{"location":"URDF/#_1","title":"Mod\u00e8le","text":""},{"location":"URDF/#_2","title":"Mod\u00e8le","text":""},{"location":"URDF/#_3","title":"Mod\u00e8le","text":""},{"location":"URDF/#_4","title":"Mod\u00e8le","text":""},{"location":"URDF/#_5","title":"Mod\u00e8le","text":""},{"location":"URDF/#_6","title":"Mod\u00e8le","text":""},{"location":"URDF/#_7","title":"Mod\u00e8le","text":""},{"location":"URDF/#_8","title":"Mod\u00e8le","text":""},{"location":"URDF/#assemblage-complet","title":"Assemblage complet","text":"<p>De la m\u00eame mani\u00e8re que pour les roues et le corps on ajoute a notre modele, les flipper, une roues libre, le lidar et la cam\u00e9ra</p> <p>toue les joints sont des joint fixes enfant du link corps</p>"},{"location":"URDF/#arborescence","title":"arborescence","text":"<ul> <li>corps<ul> <li>roue_droite</li> <li>roue_gauche</li> <li>flipper_droit</li> <li>flipper_gauche</li> <li>roue_libre</li> <li>cam\u00e9ra</li> <li>lidar</li> </ul> </li> </ul> <p>Dans le lien github suivant le mod\u00e8le complet</p> <p>GitHub</p>"}]}