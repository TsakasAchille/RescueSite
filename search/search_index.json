{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs nique t aleres For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. Liste \u00e0 puce: Element 1 Sous-\u00e9l\u00e9ment 1 Sous-\u00e9l\u00e9ment 2 Element 2 Element 3 Texte en gras texte mis en \u00e9vidence en vert","title":"Home"},{"location":"#welcome-to-mkdocs-nique-t-aleres","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs nique t aleres"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. Liste \u00e0 puce: Element 1 Sous-\u00e9l\u00e9ment 1 Sous-\u00e9l\u00e9ment 2 Element 2 Element 3 Texte en gras texte mis en \u00e9vidence en vert","title":"Project layout"},{"location":"Bt/","text":"Py Trees for ROS S\u00e9quence La sequence va executer ses enfants un \u00e0 un dans un ordre pr\u00e9d\u00e9finit, si un enfant lui renvoi SUCCESS alors il passe \u00e0 l'autre, si tous les enfant renvoient SUCESS alors il renvoi SUCCESS, si un enfants renvoient FAILURE alors il arrete la s\u00e9quence et renvoi FAILURE Selector { align=left } L'objetif ici est le suivant, dans un premeier temps nous allons verifier que nous avons pas deja un goal en attente, si c'est la cas on peut aller generer la trajectoire pour atteindre notre goal. En revanche si nous avons pas de goal present alors nous pouvons rester en attente de goal avant de poursuivre ############################################################################## # Imports ############################################################################## import functools import py_trees import py_trees_ros import py_trees.console as console +- import rospy import sys from geometry_msgs.msg import PoseStamped import geometry_msgs.msg as geometry_msgs import mbf_msgs.msg as mbf_msgs ############################################################################## # Actions ############################################################################## class GetPath ( py_trees_ros . actions . ActionClient ): def initialise ( self ): self . action_goal = mbf_msgs . GetPathGoal ( target_pose = py_trees . blackboard . Blackboard () . get ( \"target_pose\" )) super ( GetPath , self ) . initialise () def update ( self ): status = super ( GetPath , self ) . update () if status == py_trees . Status . SUCCESS : py_trees . blackboard . Blackboard () . set ( \"path\" , self . action_client . get_result () . path ) return status class ExePath ( py_trees_ros . actions . ActionClient ): def initialise ( self ): self . action_goal = mbf_msgs . ExePathGoal ( path = py_trees . blackboard . Blackboard () . get ( \"path\" )) super ( ExePath , self ) . initialise () ############################################################################## # Behaviours ############################################################################## def create_root (): # Create all behaviours bt_root = py_trees . composites . Sequence ( \"MBF BT Demo\" ) get_goal = py_trees . composites . Selector ( \"GetGoal\" ) fallback = py_trees . composites . Selector ( \"Fallback\" ) navigate = py_trees . composites . Sequence ( \"Navigate\" ) new_goal = py_trees_ros . subscribers . ToBlackboard ( name = \"NewGoal\" , topic_name = \"/move_base_simple/goal\" , topic_type = geometry_msgs . PoseStamped , blackboard_variables = { 'target_pose' : None }) have_goal = py_trees . blackboard . CheckBlackboardVariable ( name = \"HaveGoal\" , variable_name = \"target_pose\" ) clr_goal1 = py_trees . blackboard . ClearBlackboardVariable ( name = \"ClearGoal\" , variable_name = \"target_pose\" ) clr_goal2 = py_trees . blackboard . ClearBlackboardVariable ( name = \"ClearGoal\" , variable_name = \"target_pose\" ) get_path = GetPath ( name = \"GetPath\" , action_namespace = \"/move_base_flex/get_path\" , action_spec = mbf_msgs . GetPathAction ) exe_path = ExePath ( name = \"ExePath\" , action_namespace = \"/move_base_flex/exe_path\" , action_spec = mbf_msgs . ExePathAction ) # Compose tree bt_root . add_children ([ get_goal , fallback ]) get_goal . add_children ([ have_goal , new_goal ]) navigate . add_children ([ get_path , exe_path , clr_goal1 ]) fallback . add_children ([ navigate , clr_goal2 ]) return bt_root def shutdown ( behaviour_tree ): behaviour_tree . interrupt () if __name__ == '__main__' : rospy . init_node ( \"mbf_bt_demo\" ) root = create_root () behaviour_tree = py_trees_ros . trees . BehaviourTree ( root ) rospy . on_shutdown ( functools . partial ( shutdown , behaviour_tree )) if not behaviour_tree . setup ( timeout = 15 ): console . logerror ( \"failed to setup the tree, aborting.\" ) sys . exit ( 1 ) behaviour_tree . tick_tock ( 500 ) niquzta elere deded","title":"Behavior Tree"},{"location":"Bt/#py-trees-for-ros","text":"","title":"Py Trees for ROS"},{"location":"Bt/#sequence","text":"La sequence va executer ses enfants un \u00e0 un dans un ordre pr\u00e9d\u00e9finit, si un enfant lui renvoi SUCCESS alors il passe \u00e0 l'autre, si tous les enfant renvoient SUCESS alors il renvoi SUCCESS, si un enfants renvoient FAILURE alors il arrete la s\u00e9quence et renvoi FAILURE","title":"S\u00e9quence"},{"location":"Bt/#selector","text":"{ align=left } L'objetif ici est le suivant, dans un premeier temps nous allons verifier que nous avons pas deja un goal en attente, si c'est la cas on peut aller generer la trajectoire pour atteindre notre goal. En revanche si nous avons pas de goal present alors nous pouvons rester en attente de goal avant de poursuivre ############################################################################## # Imports ############################################################################## import functools import py_trees import py_trees_ros import py_trees.console as console +- import rospy import sys from geometry_msgs.msg import PoseStamped import geometry_msgs.msg as geometry_msgs import mbf_msgs.msg as mbf_msgs ############################################################################## # Actions ############################################################################## class GetPath ( py_trees_ros . actions . ActionClient ): def initialise ( self ): self . action_goal = mbf_msgs . GetPathGoal ( target_pose = py_trees . blackboard . Blackboard () . get ( \"target_pose\" )) super ( GetPath , self ) . initialise () def update ( self ): status = super ( GetPath , self ) . update () if status == py_trees . Status . SUCCESS : py_trees . blackboard . Blackboard () . set ( \"path\" , self . action_client . get_result () . path ) return status class ExePath ( py_trees_ros . actions . ActionClient ): def initialise ( self ): self . action_goal = mbf_msgs . ExePathGoal ( path = py_trees . blackboard . Blackboard () . get ( \"path\" )) super ( ExePath , self ) . initialise () ############################################################################## # Behaviours ############################################################################## def create_root (): # Create all behaviours bt_root = py_trees . composites . Sequence ( \"MBF BT Demo\" ) get_goal = py_trees . composites . Selector ( \"GetGoal\" ) fallback = py_trees . composites . Selector ( \"Fallback\" ) navigate = py_trees . composites . Sequence ( \"Navigate\" ) new_goal = py_trees_ros . subscribers . ToBlackboard ( name = \"NewGoal\" , topic_name = \"/move_base_simple/goal\" , topic_type = geometry_msgs . PoseStamped , blackboard_variables = { 'target_pose' : None }) have_goal = py_trees . blackboard . CheckBlackboardVariable ( name = \"HaveGoal\" , variable_name = \"target_pose\" ) clr_goal1 = py_trees . blackboard . ClearBlackboardVariable ( name = \"ClearGoal\" , variable_name = \"target_pose\" ) clr_goal2 = py_trees . blackboard . ClearBlackboardVariable ( name = \"ClearGoal\" , variable_name = \"target_pose\" ) get_path = GetPath ( name = \"GetPath\" , action_namespace = \"/move_base_flex/get_path\" , action_spec = mbf_msgs . GetPathAction ) exe_path = ExePath ( name = \"ExePath\" , action_namespace = \"/move_base_flex/exe_path\" , action_spec = mbf_msgs . ExePathAction ) # Compose tree bt_root . add_children ([ get_goal , fallback ]) get_goal . add_children ([ have_goal , new_goal ]) navigate . add_children ([ get_path , exe_path , clr_goal1 ]) fallback . add_children ([ navigate , clr_goal2 ]) return bt_root def shutdown ( behaviour_tree ): behaviour_tree . interrupt () if __name__ == '__main__' : rospy . init_node ( \"mbf_bt_demo\" ) root = create_root () behaviour_tree = py_trees_ros . trees . BehaviourTree ( root ) rospy . on_shutdown ( functools . partial ( shutdown , behaviour_tree )) if not behaviour_tree . setup ( timeout = 15 ): console . logerror ( \"failed to setup the tree, aborting.\" ) sys . exit ( 1 ) behaviour_tree . tick_tock ( 500 ) niquzta elere deded","title":"Selector"},{"location":"MultiMachine/","text":"Communication Multimachine En robotique il est souvent n\u00e9cessaire d'avoir plusieurs machines qui communiquent entre elles. Dans notre cas nous avons un robot mobile qui doit communiquer avec une console d\u00e9port\u00e9e Il existe plusieurs fa\u00e7ons de communiquer entre machines avec ROS Nous allons d\u00e9crire quelqu'une de ces m\u00e9thodes en pr\u00e9sentant leurs avantages et inconv\u00e9nients Dans toutes ces m\u00e9thodes des machines partage le m\u00eame r\u00e9seau. Pour que deux machines puissent communiquer correctement, il est important, dans /etc/hosts , d'ajouter la ligne suivante: Au niveau de la machine1 [IP machinne 1] [Nom machinne 1] exemple: 192.168.1.4 robot Au niveau de la machine2 [IP machinne 2] [Nom machinne 2] exemple: 192.168.1.5 console 1. Utilisation d'une machine \"ma\u00eetre\" La m\u00e9thode la plus simple et d'utiliser un master unique partag\u00e9 par plusieurs machines. Nous avons une machine \"ma\u00eetre\" qui partage son master avec des machines \"escalves\". Commande: Au niveau de la machine ma\u00eetre, dans un terminal: export ROS_HOSTNAME={IP MAITRE} export ROS_MASTER_URI=http://{IP MAITRE}:11311 Au niveau de la machine esclave, dans un terminal: export ROS_HOSTNAME={IP ESCLAVE} export ROS_MASTER_URI=http://{IP MAITRE}:11311 Exemple: Prenons un exemple, nous avons deux machine, un robot et une console, d'adresse IP respective suivante : 192.168.1.1 et 192.168.1.2 Ici, on utilise le master de la console. Au niveau de la console, dans un terminal: export ROS_HOSTNAME=192.168.1.1 export ROS_MASTER_URI=http://192.168.1.1:11311 Au niveau du robot, dans un terminal: export ROS_HOSTNAME=192.168.1.2 export ROS_MASTER_URI=http://192.168.1.1:11311 Ainsi les deux machines partage le m\u00eame master et peuvent donc echanger des topics. Avantage Cette m\u00e9thode et simple et rapide \u00e0 mettre en place. Inconveniants Le probl\u00e8me est l'ulisation d'un master unique. En effet si une machine \"esclave\" pert la connection avec la machine \"ma\u00eetre\" alors elle pert le master et ne peut donc plus utiliser les nodes ROS. Dans notre cas si le robot s'eloigne de notre console est se deconnecte alors il ne pourra plus utiliser ROS. 2. Utilisation de la classe c++ ros::master Cette m\u00e9thode plus compliqu\u00e9 mais elle permet d'utiliser plusieurs master. Pour cela une machine se connecte au master d'une machine \"cible\" souscrit a un topic et publie une copie de ce m\u00eame topic dans son environement local (master local) Il existe une methode de la classe ros, ros::master::init() qui peremt de se connecte \u00e0 un autre master dans le m\u00eame reseau. Attention, pour utiliser cette m\u00e9thode il important d'ajouter au niveau de chaque machine dans /etc/hosts les adresses IP des autres machines Exemple de code : dans le code suivant une console se connecte au master d'un robot, souscirt a son topic SCAN et publie une copie de ce topic dans son environnement local. int main ( int argc , char ** argv ) { // On initialse notre node scan_copieur dans l'environnement local ros :: init ( argc , argv , \"scan_copieur\" ); ros :: NodeHandle nh ; // on cr\u00e9er un objet de notre classe PublisherLocal, on appel ainsi le constructeur qui cr\u00e9\u00e9 un publisher local PublisherLocal PublisherLocal ; //On declare les deux environemments std :: string robot_master = \"http://192.168.1.4::11311\" ; std :: string console_master = \"http://192.168.1.5::11311\" ; //On cr\u00e9e une varibale map M_string et on insere \u00e0 l'index __master le master auquel on veux se connecter ros :: M_string remappings ; remappings [ \"__master\" ] = robot_master ; //On se connecte au master souhait\u00e9 ros :: master :: init ( remappings ); //On souscrit au topic Scan, ici on souscrit dans l'environnement du robot_master ros :: Subscriber subscriberFeedback = nh . subscribe ( \"/scan\" , 1000 , & PublisherLocal :: callback , & hostTopic ); [....] } class PublisherLocal { public : PublisherLocal (); ~ PublisherLocal (); void callback ( const sensor_msgs :: LaserScan msg ); ros :: Publisher pub ; private : ros :: NodeHandle n ; }; PublisherLocal :: PublisherLocal () { pub = n . advertise < sensor_msgs :: LaserScan > ( \"/scan\" , 1000 ); } PublisherLocal ::~ PublisherLocal (){} void PublisherLocal :: callback ( const sensor_msgs :: LaserScan msg ){ if ( ok == 1 ){ oldSeq = msg . header . seq ; ok = 0 ; } else { newSeq = msg . header . seq ; ok = 1 ; } if ( newSeq > oldSeq ) pub . publish ( msg ); } Voir code complet -> [lien git hub] Avantage Cette m\u00e9thode permet d'avoir plus de contr\u00f4les sur la connexion entre machines, elle rend la communication plus flexible. Chaque machine garde son propre master et peut donc \u00eatre ind\u00e9pendante de la connexion r\u00e9seau. Inconveniants La m\u00e9thode est plus complexe et est unidirectionnelle, en effet dans l'exemple pr\u00e9sent\u00e9 pr\u00e9c\u00e9demment, il s'agit d'une lecture et recopie mais pas d'un r\u00e9el \u00e9change de topic. Si plusieurs topics doivent \u00eatre \u00e9chang\u00e9s, il devient fastidieux de r\u00e9aliser une recopie pour chaque topic. 3. Utilisation de ROS Bridge Dans l'exemple suivant nous allons utilis\u00e9 ROS2. L'avantage de ROS2 est que la communication se fait sans Master. Nous allons utliser ROS 2 pour transferer les topic d'une machine ROS1 \u00e0 une autre machine ROS1 Au niveau de la machine 1 export ROS_MASTER_URI=http://192.168.1.4:11311 export ROS_HOSTNAME=192.168.1.4 Au niveau de la machine 2 Premier terminal export ROS_MASTER_URI=http://192.168.1.4:11311 source ROS1 source ROS2 ros2 run ros1_bridge dynamic_bridge --bridge-all-topics Deuxi\u00e8me terminal source ROS1 source ROS2 ros2 run ros1_bridge dynamic_bridge --bridge-all-topics Ce script .sh permet d'automatiser la connection export ROS_MASTER_URI = http://192.168.1.4:11311 source ${ ROS1 } source ${ ROS2 } gnome-terminal --tab --command = \"ros2 run ros1_bridge dynamic_bridge --bridge-all-topics\" export ROS_MASTER_URI = http://localhost:11311 source ${ ROS1 } source ${ ROS2 } gnome-terminal --tab --command = \"ros2 run ros1_bridge dynamic_bridge --bridge-all-topics\" source ${ ROS1 } source devel/setup.bash roslaunch nodes starting_launch.launch #lancement d'un node dans ROS1 local","title":"Multi Machine"},{"location":"MultiMachine/#communication-multimachine","text":"En robotique il est souvent n\u00e9cessaire d'avoir plusieurs machines qui communiquent entre elles. Dans notre cas nous avons un robot mobile qui doit communiquer avec une console d\u00e9port\u00e9e Il existe plusieurs fa\u00e7ons de communiquer entre machines avec ROS Nous allons d\u00e9crire quelqu'une de ces m\u00e9thodes en pr\u00e9sentant leurs avantages et inconv\u00e9nients Dans toutes ces m\u00e9thodes des machines partage le m\u00eame r\u00e9seau. Pour que deux machines puissent communiquer correctement, il est important, dans /etc/hosts , d'ajouter la ligne suivante:","title":"Communication Multimachine"},{"location":"MultiMachine/#au-niveau-de-la-machine1","text":"[IP machinne 1] [Nom machinne 1] exemple: 192.168.1.4 robot","title":"Au niveau de la machine1"},{"location":"MultiMachine/#au-niveau-de-la-machine2","text":"[IP machinne 2] [Nom machinne 2] exemple: 192.168.1.5 console","title":"Au niveau de la machine2"},{"location":"MultiMachine/#1-utilisation-dune-machine-maitre","text":"La m\u00e9thode la plus simple et d'utiliser un master unique partag\u00e9 par plusieurs machines. Nous avons une machine \"ma\u00eetre\" qui partage son master avec des machines \"escalves\".","title":"1. Utilisation d'une machine \"ma\u00eetre\""},{"location":"MultiMachine/#commande","text":"Au niveau de la machine ma\u00eetre, dans un terminal: export ROS_HOSTNAME={IP MAITRE} export ROS_MASTER_URI=http://{IP MAITRE}:11311 Au niveau de la machine esclave, dans un terminal: export ROS_HOSTNAME={IP ESCLAVE} export ROS_MASTER_URI=http://{IP MAITRE}:11311","title":"Commande:"},{"location":"MultiMachine/#exemple","text":"Prenons un exemple, nous avons deux machine, un robot et une console, d'adresse IP respective suivante : 192.168.1.1 et 192.168.1.2 Ici, on utilise le master de la console. Au niveau de la console, dans un terminal: export ROS_HOSTNAME=192.168.1.1 export ROS_MASTER_URI=http://192.168.1.1:11311 Au niveau du robot, dans un terminal: export ROS_HOSTNAME=192.168.1.2 export ROS_MASTER_URI=http://192.168.1.1:11311 Ainsi les deux machines partage le m\u00eame master et peuvent donc echanger des topics.","title":"Exemple:"},{"location":"MultiMachine/#avantage","text":"Cette m\u00e9thode et simple et rapide \u00e0 mettre en place.","title":"Avantage"},{"location":"MultiMachine/#inconveniants","text":"Le probl\u00e8me est l'ulisation d'un master unique. En effet si une machine \"esclave\" pert la connection avec la machine \"ma\u00eetre\" alors elle pert le master et ne peut donc plus utiliser les nodes ROS. Dans notre cas si le robot s'eloigne de notre console est se deconnecte alors il ne pourra plus utiliser ROS.","title":"Inconveniants"},{"location":"MultiMachine/#2-utilisation-de-la-classe-c-rosmaster","text":"Cette m\u00e9thode plus compliqu\u00e9 mais elle permet d'utiliser plusieurs master. Pour cela une machine se connecte au master d'une machine \"cible\" souscrit a un topic et publie une copie de ce m\u00eame topic dans son environement local (master local) Il existe une methode de la classe ros, ros::master::init() qui peremt de se connecte \u00e0 un autre master dans le m\u00eame reseau. Attention, pour utiliser cette m\u00e9thode il important d'ajouter au niveau de chaque machine dans /etc/hosts les adresses IP des autres machines","title":"2. Utilisation de la classe c++ ros::master"},{"location":"MultiMachine/#exemple-de-code","text":"dans le code suivant une console se connecte au master d'un robot, souscirt a son topic SCAN et publie une copie de ce topic dans son environnement local. int main ( int argc , char ** argv ) { // On initialse notre node scan_copieur dans l'environnement local ros :: init ( argc , argv , \"scan_copieur\" ); ros :: NodeHandle nh ; // on cr\u00e9er un objet de notre classe PublisherLocal, on appel ainsi le constructeur qui cr\u00e9\u00e9 un publisher local PublisherLocal PublisherLocal ; //On declare les deux environemments std :: string robot_master = \"http://192.168.1.4::11311\" ; std :: string console_master = \"http://192.168.1.5::11311\" ; //On cr\u00e9e une varibale map M_string et on insere \u00e0 l'index __master le master auquel on veux se connecter ros :: M_string remappings ; remappings [ \"__master\" ] = robot_master ; //On se connecte au master souhait\u00e9 ros :: master :: init ( remappings ); //On souscrit au topic Scan, ici on souscrit dans l'environnement du robot_master ros :: Subscriber subscriberFeedback = nh . subscribe ( \"/scan\" , 1000 , & PublisherLocal :: callback , & hostTopic ); [....] } class PublisherLocal { public : PublisherLocal (); ~ PublisherLocal (); void callback ( const sensor_msgs :: LaserScan msg ); ros :: Publisher pub ; private : ros :: NodeHandle n ; }; PublisherLocal :: PublisherLocal () { pub = n . advertise < sensor_msgs :: LaserScan > ( \"/scan\" , 1000 ); } PublisherLocal ::~ PublisherLocal (){} void PublisherLocal :: callback ( const sensor_msgs :: LaserScan msg ){ if ( ok == 1 ){ oldSeq = msg . header . seq ; ok = 0 ; } else { newSeq = msg . header . seq ; ok = 1 ; } if ( newSeq > oldSeq ) pub . publish ( msg ); } Voir code complet -> [lien git hub]","title":"Exemple de code :"},{"location":"MultiMachine/#avantage_1","text":"Cette m\u00e9thode permet d'avoir plus de contr\u00f4les sur la connexion entre machines, elle rend la communication plus flexible. Chaque machine garde son propre master et peut donc \u00eatre ind\u00e9pendante de la connexion r\u00e9seau.","title":"Avantage"},{"location":"MultiMachine/#inconveniants_1","text":"La m\u00e9thode est plus complexe et est unidirectionnelle, en effet dans l'exemple pr\u00e9sent\u00e9 pr\u00e9c\u00e9demment, il s'agit d'une lecture et recopie mais pas d'un r\u00e9el \u00e9change de topic. Si plusieurs topics doivent \u00eatre \u00e9chang\u00e9s, il devient fastidieux de r\u00e9aliser une recopie pour chaque topic.","title":"Inconveniants"},{"location":"MultiMachine/#3-utilisation-de-ros-bridge","text":"Dans l'exemple suivant nous allons utilis\u00e9 ROS2. L'avantage de ROS2 est que la communication se fait sans Master. Nous allons utliser ROS 2 pour transferer les topic d'une machine ROS1 \u00e0 une autre machine ROS1","title":"3. Utilisation de ROS Bridge"},{"location":"MultiMachine/#au-niveau-de-la-machine-1","text":"export ROS_MASTER_URI=http://192.168.1.4:11311 export ROS_HOSTNAME=192.168.1.4","title":"Au niveau de la machine 1"},{"location":"MultiMachine/#au-niveau-de-la-machine-2","text":"Premier terminal export ROS_MASTER_URI=http://192.168.1.4:11311 source ROS1 source ROS2 ros2 run ros1_bridge dynamic_bridge --bridge-all-topics Deuxi\u00e8me terminal source ROS1 source ROS2 ros2 run ros1_bridge dynamic_bridge --bridge-all-topics Ce script .sh permet d'automatiser la connection export ROS_MASTER_URI = http://192.168.1.4:11311 source ${ ROS1 } source ${ ROS2 } gnome-terminal --tab --command = \"ros2 run ros1_bridge dynamic_bridge --bridge-all-topics\" export ROS_MASTER_URI = http://localhost:11311 source ${ ROS1 } source ${ ROS2 } gnome-terminal --tab --command = \"ros2 run ros1_bridge dynamic_bridge --bridge-all-topics\" source ${ ROS1 } source devel/setup.bash roslaunch nodes starting_launch.launch #lancement d'un node dans ROS1 local","title":"Au niveau de la machine 2"},{"location":"Nav/","text":"Move base Flex Move_base_flex est un composant ROS (Robot Operating System) utilis\u00e9 pour la planification de la navigation autonome dans un environnement de robot. Il fournit une solution pour la planification de la navigation autonome en utilisant des algorithmes de planification de la trajectoire et de la gestion de la carte de co\u00fbts. MoveBaseFlex est une extension de la biblioth\u00e8que de navigation de base de ROS (Robot Operating System), qui est \u00e9galement appel\u00e9e MoveBase. MoveBaseFlex h\u00e9rite du fonctionnement de base de MoveBase, mais ajoute des fonctionnalit\u00e9s suppl\u00e9mentaires pour prendre en charge diff\u00e9rents algorithmes de planification et de suivi de chemin pour les robots mobiles. MoveBaseFlex est con\u00e7u pour \u00eatre plus flexible que MoveBase et peut \u00eatre utilis\u00e9 pour des sc\u00e9narios de navigation plus complexes. Il permet de changer facilement les algorithmes de planification et de suivi de chemin en fonction des besoins sp\u00e9cifiques de l'application, sans avoir \u00e0 modifier le code source. Voir -> Documentation Move_Base_Flex source devel/setup.bash export TURTLEBOT3_MODEL=rescue roslaunch turtlebot3_gazebo turtlebot3_world.launch source devel/setup.bash export TURTLEBOT3_MODEL=rescue roslaunch mbf_advanced amcl_demo_mbf_recovery.launch source devel/setup.bash rosrun mbf_advanced pytreesRecovery.py rosrun rqt_py_trees rqt_py_trees Move base Client Le launch file suivant lance \"move_base_flex\". Ce noeud appartient au package \"mbf_costmap_nav\" et utilise le type \"mbf_costmap_nav\". Le noeud charge plusieurs fichiers de param\u00e8tres ROS \u00e0 l'aide de la commande \"rosparam\". Les fichiers de param\u00e8tres d\u00e9finissent les comportements du noeud \"move_base_flex\", tels que les param\u00e8tres de co\u00fbts pour les cartes locales et globales de l'environnement ainsi que les param\u00e8tres de planification de la base locale. Les param\u00e8tres de r\u00e9cup\u00e9ration \"move_base_flex_recovery\" sont \u00e9galement charg\u00e9s pour d\u00e9finir les comportements de r\u00e9cup\u00e9ration. <node name= \"move_base_flex\" pkg= \"mbf_costmap_nav\" type= \"mbf_costmap_nav\" required= \"true\" output= \"screen\" clear_params= \"true\" > <rosparam file= \"$(find mbf_advanced)/param/move_base_classic/costmap_common_params_$(arg model).yaml\" command= \"load\" ns= \"global_costmap\" /> <rosparam file= \"$(find mbf_advanced)/param/move_base_classic/costmap_common_params_$(arg model).yaml\" command= \"load\" ns= \"local_costmap\" /> <rosparam file= \"$(find mbf_advanced)/param/move_base_classic/local_costmap_params.yaml\" command= \"load\" /> <rosparam file= \"$(find mbf_advanced)/param/move_base_classic/global_costmap_params.yaml\" command= \"load\" /> <rosparam file= \"$(find mbf_advanced)/param/move_base_flex_recovery.yaml\" command= \"load\" /> <rosparam file= \"$(find mbf_advanced)/param/move_base_classic/base_local_planner_params.yaml\" command= \"load\" /> </node> Nous incluons les different param\u00e8tre necessaire pour parametre nos plugins La premiere etape et de se soscrire au topic poseStamped qui peremt d'envyer un goal et d'envoyer ce goal a move base en utilisant les action de action lib #!/usr/bin/env python import actionlib import rospy import nav_msgs.srv as nav_srvs import mbf_msgs.msg as mbf_msgs import move_base_msgs.msg as mb_msgs from geometry_msgs.msg import PoseStamped def simple_goal_cb ( msg ): mbf_mb_ac . send_goal ( mbf_msgs . MoveBaseGoal ( target_pose = msg )) rospy . logdebug ( \"Relaying move_base_simple/goal pose to mbf\" ) mbf_mb_ac . wait_for_result () status = mbf_mb_ac . get_state () result = mbf_mb_ac . get_result () rospy . logdebug ( \"MBF execution completed with result [ %d ]: %s \" , result . outcome , result . message ) if __name__ == '__main__' : rospy . init_node ( \"move_base_relay\" ) # move base flex ation client relays incoming mb goals to mbf mbf_mb_ac = actionlib . SimpleActionClient ( \"move_base_flex/move_base\" , mbf_msgs . MoveBaseAction ) mbf_mb_ac . wait_for_server ( rospy . Duration ( 20 )) # move_base simple topic and action server mb_sg = rospy . Subscriber ( 'move_base_simple/goal' , PoseStamped , simple_goal_cb ) rospy . on_shutdown ( lambda : mbf_mb_ac . cancel_all_goals ()) rospy . spin () sd Explication du code: mb_sg = rospy . Subscriber ( 'move_base_simple/goal' , PoseStamped , simple_goal_cb ) On cr\u00e9er un subsciber \"mb_sb\" qui souscit au topic \"move_base_simple/goal\" de type PoseStamped dont le CallBack et la fonction simple_goal_cb mbf_mb_ac = actionlib . SimpleActionClient ( \"move_base_flex/move_base\" , mbf_msgs . MoveBaseAction ) mbf_mb_ac . wait_for_server ( rospy . Duration ( 20 )) On instancit un client mbf_mb_ac qui va se connecter au node (serveur) /move_base_flex avec commme action : /move_base_flex/move_base Le node move_base_flex dispose de plusieur action (fichier source dans /move_base_flex/mbf_abstract_nav/src/move_base_action.cpp) Whatch py_tree doc http://docs.ros.org/en/kinetic/api/py_trees_ros/html/tutorials.html","title":"Move_Base_Flex"},{"location":"Nav/#move-base-flex","text":"Move_base_flex est un composant ROS (Robot Operating System) utilis\u00e9 pour la planification de la navigation autonome dans un environnement de robot. Il fournit une solution pour la planification de la navigation autonome en utilisant des algorithmes de planification de la trajectoire et de la gestion de la carte de co\u00fbts. MoveBaseFlex est une extension de la biblioth\u00e8que de navigation de base de ROS (Robot Operating System), qui est \u00e9galement appel\u00e9e MoveBase. MoveBaseFlex h\u00e9rite du fonctionnement de base de MoveBase, mais ajoute des fonctionnalit\u00e9s suppl\u00e9mentaires pour prendre en charge diff\u00e9rents algorithmes de planification et de suivi de chemin pour les robots mobiles. MoveBaseFlex est con\u00e7u pour \u00eatre plus flexible que MoveBase et peut \u00eatre utilis\u00e9 pour des sc\u00e9narios de navigation plus complexes. Il permet de changer facilement les algorithmes de planification et de suivi de chemin en fonction des besoins sp\u00e9cifiques de l'application, sans avoir \u00e0 modifier le code source. Voir -> Documentation Move_Base_Flex source devel/setup.bash export TURTLEBOT3_MODEL=rescue roslaunch turtlebot3_gazebo turtlebot3_world.launch","title":"Move base Flex"},{"location":"Nav/#_1","text":"source devel/setup.bash export TURTLEBOT3_MODEL=rescue roslaunch mbf_advanced amcl_demo_mbf_recovery.launch","title":""},{"location":"Nav/#_2","text":"source devel/setup.bash rosrun mbf_advanced pytreesRecovery.py","title":""},{"location":"Nav/#_3","text":"rosrun rqt_py_trees rqt_py_trees","title":""},{"location":"Nav/#move-base-client","text":"Le launch file suivant lance \"move_base_flex\". Ce noeud appartient au package \"mbf_costmap_nav\" et utilise le type \"mbf_costmap_nav\". Le noeud charge plusieurs fichiers de param\u00e8tres ROS \u00e0 l'aide de la commande \"rosparam\". Les fichiers de param\u00e8tres d\u00e9finissent les comportements du noeud \"move_base_flex\", tels que les param\u00e8tres de co\u00fbts pour les cartes locales et globales de l'environnement ainsi que les param\u00e8tres de planification de la base locale. Les param\u00e8tres de r\u00e9cup\u00e9ration \"move_base_flex_recovery\" sont \u00e9galement charg\u00e9s pour d\u00e9finir les comportements de r\u00e9cup\u00e9ration. <node name= \"move_base_flex\" pkg= \"mbf_costmap_nav\" type= \"mbf_costmap_nav\" required= \"true\" output= \"screen\" clear_params= \"true\" > <rosparam file= \"$(find mbf_advanced)/param/move_base_classic/costmap_common_params_$(arg model).yaml\" command= \"load\" ns= \"global_costmap\" /> <rosparam file= \"$(find mbf_advanced)/param/move_base_classic/costmap_common_params_$(arg model).yaml\" command= \"load\" ns= \"local_costmap\" /> <rosparam file= \"$(find mbf_advanced)/param/move_base_classic/local_costmap_params.yaml\" command= \"load\" /> <rosparam file= \"$(find mbf_advanced)/param/move_base_classic/global_costmap_params.yaml\" command= \"load\" /> <rosparam file= \"$(find mbf_advanced)/param/move_base_flex_recovery.yaml\" command= \"load\" /> <rosparam file= \"$(find mbf_advanced)/param/move_base_classic/base_local_planner_params.yaml\" command= \"load\" /> </node> Nous incluons les different param\u00e8tre necessaire pour parametre nos plugins La premiere etape et de se soscrire au topic poseStamped qui peremt d'envyer un goal et d'envoyer ce goal a move base en utilisant les action de action lib #!/usr/bin/env python import actionlib import rospy import nav_msgs.srv as nav_srvs import mbf_msgs.msg as mbf_msgs import move_base_msgs.msg as mb_msgs from geometry_msgs.msg import PoseStamped def simple_goal_cb ( msg ): mbf_mb_ac . send_goal ( mbf_msgs . MoveBaseGoal ( target_pose = msg )) rospy . logdebug ( \"Relaying move_base_simple/goal pose to mbf\" ) mbf_mb_ac . wait_for_result () status = mbf_mb_ac . get_state () result = mbf_mb_ac . get_result () rospy . logdebug ( \"MBF execution completed with result [ %d ]: %s \" , result . outcome , result . message ) if __name__ == '__main__' : rospy . init_node ( \"move_base_relay\" ) # move base flex ation client relays incoming mb goals to mbf mbf_mb_ac = actionlib . SimpleActionClient ( \"move_base_flex/move_base\" , mbf_msgs . MoveBaseAction ) mbf_mb_ac . wait_for_server ( rospy . Duration ( 20 )) # move_base simple topic and action server mb_sg = rospy . Subscriber ( 'move_base_simple/goal' , PoseStamped , simple_goal_cb ) rospy . on_shutdown ( lambda : mbf_mb_ac . cancel_all_goals ()) rospy . spin () sd Explication du code: mb_sg = rospy . Subscriber ( 'move_base_simple/goal' , PoseStamped , simple_goal_cb ) On cr\u00e9er un subsciber \"mb_sb\" qui souscit au topic \"move_base_simple/goal\" de type PoseStamped dont le CallBack et la fonction simple_goal_cb mbf_mb_ac = actionlib . SimpleActionClient ( \"move_base_flex/move_base\" , mbf_msgs . MoveBaseAction ) mbf_mb_ac . wait_for_server ( rospy . Duration ( 20 )) On instancit un client mbf_mb_ac qui va se connecter au node (serveur) /move_base_flex avec commme action : /move_base_flex/move_base Le node move_base_flex dispose de plusieur action (fichier source dans /move_base_flex/mbf_abstract_nav/src/move_base_action.cpp) Whatch py_tree doc http://docs.ros.org/en/kinetic/api/py_trees_ros/html/tutorials.html","title":"Move base Client"},{"location":"Plugins/","text":"URDF <?xml version=\"1.0\" ?> <robot name= \"turtlebot3_burger\" xmlns:xacro= \"http://ros.org/wiki/xacro\" > <xacro:include filename= \"$(find turtlebot3_description)/urdf/common_properties.xacro\" /> <xacro:include filename= \"$(find turtlebot3_description)/urdf/turtlebot3_burger.gazebo.xacro\" /> Le premier, common_properties.xacro permet de definir la couleur des links utilis\u00e9 en code RGB Le deuxieme, turtlebot3_burger.gazebo.xacro, contient les param\u00e8tres physiques appliqu\u00e9 \u00e0 nos joint comme le frotement ou l\u2019inertie et des plugin utilis\u00e9 lors de la simulation. Plugins turtlebot3_burger_controller Il permet de contr\u00f4ler le robot en publiant dasn un topic et de generer une odom\u00e9trie <gazebo> <plugin name= \"turtlebot3_burger_controller\" filename= \"libgazebo_ros_diff_drive.so\" > <commandTopic> cmd_vel </commandTopic> <odometryTopic> odom </odometryTopic> <odometryFrame> odom </odometryFrame> <odometrySource> world </odometrySource> <publishOdomTF> true </publishOdomTF> <robotBaseFrame> base_footprint </robotBaseFrame> <publishWheelTF> false </publishWheelTF> <publishTf> true </publishTf> <publishWheelJointState> true </publishWheelJointState> <legacyMode> false </legacyMode> <updateRate> 30 </updateRate> <leftJoint> wheel_left_joint </leftJoint> <rightJoint> wheel_right_joint </rightJoint> <wheelSeparation> 0.160 </wheelSeparation> <wheelDiameter> 0.066 </wheelDiameter> <wheelAcceleration> 1 </wheelAcceleration> <wheelTorque> 10 </wheelTorque> <rosDebugLevel> na </rosDebugLevel> </plugin> </gazebo> Ici nous pouvons controler le robot en publiant dans \u201ccmd_vel\u201d, le topic odom\u00e9trie et \u201codom\u201d et la transformation ce fait entre \u201codom\u201d et \u201cbase_footprint\u201d gazebo_ros_lds_lfcd_controller Ce plugin permet de simuler un lidar: <plugin name= \"gazebo_ros_lds_lfcd_controller\" filename= \"libgazebo_ros_laser.so\" > <topicName> scan </topicName> <frameName> base_scan </frameName> </plugin> Il gen\u00e8re un topic \u201cscan\u201d dont le nom est definti dans TopicName , le scan ce fait dans le plan definti par le link frameName ici, \u201cbase-scan\u201d.","title":"Plugins"},{"location":"Plugins/#urdf","text":"<?xml version=\"1.0\" ?> <robot name= \"turtlebot3_burger\" xmlns:xacro= \"http://ros.org/wiki/xacro\" > <xacro:include filename= \"$(find turtlebot3_description)/urdf/common_properties.xacro\" /> <xacro:include filename= \"$(find turtlebot3_description)/urdf/turtlebot3_burger.gazebo.xacro\" /> Le premier, common_properties.xacro permet de definir la couleur des links utilis\u00e9 en code RGB Le deuxieme, turtlebot3_burger.gazebo.xacro, contient les param\u00e8tres physiques appliqu\u00e9 \u00e0 nos joint comme le frotement ou l\u2019inertie et des plugin utilis\u00e9 lors de la simulation.","title":"URDF"},{"location":"Plugins/#plugins","text":"turtlebot3_burger_controller Il permet de contr\u00f4ler le robot en publiant dasn un topic et de generer une odom\u00e9trie <gazebo> <plugin name= \"turtlebot3_burger_controller\" filename= \"libgazebo_ros_diff_drive.so\" > <commandTopic> cmd_vel </commandTopic> <odometryTopic> odom </odometryTopic> <odometryFrame> odom </odometryFrame> <odometrySource> world </odometrySource> <publishOdomTF> true </publishOdomTF> <robotBaseFrame> base_footprint </robotBaseFrame> <publishWheelTF> false </publishWheelTF> <publishTf> true </publishTf> <publishWheelJointState> true </publishWheelJointState> <legacyMode> false </legacyMode> <updateRate> 30 </updateRate> <leftJoint> wheel_left_joint </leftJoint> <rightJoint> wheel_right_joint </rightJoint> <wheelSeparation> 0.160 </wheelSeparation> <wheelDiameter> 0.066 </wheelDiameter> <wheelAcceleration> 1 </wheelAcceleration> <wheelTorque> 10 </wheelTorque> <rosDebugLevel> na </rosDebugLevel> </plugin> </gazebo> Ici nous pouvons controler le robot en publiant dans \u201ccmd_vel\u201d, le topic odom\u00e9trie et \u201codom\u201d et la transformation ce fait entre \u201codom\u201d et \u201cbase_footprint\u201d gazebo_ros_lds_lfcd_controller Ce plugin permet de simuler un lidar: <plugin name= \"gazebo_ros_lds_lfcd_controller\" filename= \"libgazebo_ros_laser.so\" > <topicName> scan </topicName> <frameName> base_scan </frameName> </plugin> Il gen\u00e8re un topic \u201cscan\u201d dont le nom est definti dans TopicName , le scan ce fait dans le plan definti par le link frameName ici, \u201cbase-scan\u201d.","title":"Plugins"},{"location":"Recovery/","text":"Recovery dans move_base_flex_recovery.yaml nous ajoutons les plugins que l'on shoaie utiliser planners : - name : navfn/NavfnROS type : navfn/NavfnROS - name : global_planner/GlobalPlanner type : global_planner/GlobalPlanner controllers : - name : dwa_local_planner/DWAPlannerROS type : dwa_local_planner/DWAPlannerROS #- name: eband_local_planner/EBandPlannerROS # type: eband_local_planner/EBandPlannerROS # - name: teb_local_planner/TebLocalPlannerROS # type: teb_local_planner/TebLocalPlannerROS recovery_behaviors : - name : 'rotate_recovery/RotateRecovery' type : 'rotate_recovery/RotateRecovery' - name : clear_costmap_recovery type : clear_costmap_recovery/ClearCostmapRecovery - name : 'moveback_recovery' type : 'moveback_recovery/MoveBackRecovery' moveback_recovery : linear_vel_back : -0.4 # default -0.3 step_back_length : 0.3 # default 1.0 step_back_timeout : 5.0 # default 15.0 controller_frequency : 5.0 controller_patience : 10.0 controller_max_retries : 10 planner_frequency : 1 planner_patience : 10.0 planner_max_retries : 10 recovery_enabled : true recovery_patience : 15.0 oscillation_timeout : 10.0 oscillation_distance : 0.2 Rotate Recovery Le plugin rotate_recovery/RotateRecovery est un plugin custum -> Cr\u00e9er son propre plugin qui met en roation le robot et s'arreter lorsqu'il est align\u00e9 avec la trajectoire Lors d'une rotation le robot s'arrette si il detecte un obstacle et revoi le code 159 [CANT_TURN] Move Back Recovery Ce Recovery fait reculer le robot a une distance et avec une vitesse definit Le robot s'arrette si il detecte un obstacle et revoi le code 150 [FAILURE]","title":"Recovery Plugins"},{"location":"Recovery/#recovery","text":"dans move_base_flex_recovery.yaml nous ajoutons les plugins que l'on shoaie utiliser planners : - name : navfn/NavfnROS type : navfn/NavfnROS - name : global_planner/GlobalPlanner type : global_planner/GlobalPlanner controllers : - name : dwa_local_planner/DWAPlannerROS type : dwa_local_planner/DWAPlannerROS #- name: eband_local_planner/EBandPlannerROS # type: eband_local_planner/EBandPlannerROS # - name: teb_local_planner/TebLocalPlannerROS # type: teb_local_planner/TebLocalPlannerROS recovery_behaviors : - name : 'rotate_recovery/RotateRecovery' type : 'rotate_recovery/RotateRecovery' - name : clear_costmap_recovery type : clear_costmap_recovery/ClearCostmapRecovery - name : 'moveback_recovery' type : 'moveback_recovery/MoveBackRecovery' moveback_recovery : linear_vel_back : -0.4 # default -0.3 step_back_length : 0.3 # default 1.0 step_back_timeout : 5.0 # default 15.0 controller_frequency : 5.0 controller_patience : 10.0 controller_max_retries : 10 planner_frequency : 1 planner_patience : 10.0 planner_max_retries : 10 recovery_enabled : true recovery_patience : 15.0 oscillation_timeout : 10.0 oscillation_distance : 0.2","title":"Recovery"},{"location":"Recovery/#rotate-recovery","text":"Le plugin rotate_recovery/RotateRecovery est un plugin custum -> Cr\u00e9er son propre plugin qui met en roation le robot et s'arreter lorsqu'il est align\u00e9 avec la trajectoire Lors d'une rotation le robot s'arrette si il detecte un obstacle et revoi le code 159 [CANT_TURN]","title":"Rotate Recovery"},{"location":"Recovery/#move-back-recovery","text":"Ce Recovery fait reculer le robot a une distance et avec une vitesse definit Le robot s'arrette si il detecte un obstacle et revoi le code 150 [FAILURE]","title":"Move Back Recovery"},{"location":"Recovery_Plugin/","text":"Le paquet move_base_flex de ROS utilise un syst\u00e8me de plugins pour permettre la s\u00e9lection de diff\u00e9rents comportements de navigation en fonction des conditions du terrain et des capacit\u00e9s du robot. Parmi les plugins disponibles, il y a un plugin de recovery qui est utilis\u00e9 pour g\u00e9rer les cas d'\u00e9chec de navigation, tels que les blocages, les collisions et les erreurs de planification. Ce plugin est appel\u00e9 lorsqu'un \u00e9chec de navigation est d\u00e9tect\u00e9 pour permettre au robot de se remettre sur la bonne voie et de continuer \u00e0 atteindre son objectif. Pour appeler le plugin de recovery, la fonction move_base_flex utilise la fonction ROS \"recover\" qui est d\u00e9finie dans le paquet move_base. Cette fonction est appel\u00e9e lorsqu'un \u00e9chec de navigation est d\u00e9tect\u00e9, et elle utilise la liste de plugins de recovery configur\u00e9e pour s\u00e9lectionner le plugin appropri\u00e9 \u00e0 utiliser pour r\u00e9soudre l'\u00e9chec. Le syst\u00e8me de r\u00e9cup\u00e9ration de MBF est con\u00e7u pour \u00eatre flexible et extensible, de sorte que de nouveaux comportements de r\u00e9cup\u00e9ration peuvent \u00eatre facilement ajout\u00e9s ou modifi\u00e9s pour r\u00e9pondre aux besoins de diff\u00e9rents environnements de navigation. La classe CostmapRecovery d\u00e9finit une interface pour les comportements de r\u00e9cup\u00e9ration utilis\u00e9s dans la navigation. Elle h\u00e9rite de la classe mbf_abstract_core::AbstractRecovery et doit \u00eatre impl\u00e9ment\u00e9e par tous plugins de r\u00e9cup\u00e9ration qui souhaite \u00eatre utilis\u00e9 dans le syst\u00e8me de navigation MBF. La classe CostmapRecovery #ifndef MBF_COSTMAP_CORE__COSTMAP_RECOVERY_H_ #define MBF_COSTMAP_CORE__COSTMAP_RECOVERY_H_ #include <mbf_abstract_core/abstract_recovery.h> #include <costmap_2d/costmap_2d_ros.h> #include <mbf_utility/types.h> namespace mbf_costmap_core { /** * @class CostmapRecovery * @brief Provides an interface for recovery behaviors used in navigation. * All recovery behaviors written to work as MBF plugins must adhere to this interface. Alternatively, this * class can also operate as a wrapper for old API nav_corebased plugins, providing backward compatibility. */ class CostmapRecovery : public mbf_abstract_core :: AbstractRecovery { public : typedef boost :: shared_ptr < :: mbf_costmap_core :: CostmapRecovery > Ptr ; /** * @brief Initialization function for the CostmapRecovery * @param tf A pointer to a transform listener * @param global_costmap A pointer to the global_costmap used by the navigation stack * @param local_costmap A pointer to the local_costmap used by the navigation stack */ virtual void initialize ( std :: string name , TF * tf , costmap_2d :: Costmap2DROS * global_costmap , costmap_2d :: Costmap2DROS * local_costmap ) = 0 ; /** * @brief Runs the CostmapRecovery * @param message The recovery behavior could set, the message should correspond to the return value * @return An outcome which will be hand over to the action result. */ virtual uint32_t runBehavior ( std :: string & message ) = 0 ; /** * @brief Requests the planner to cancel, e.g. if it takes too much time * @remark New on MBF API * @return True if a cancel has been successfully requested, false if not implemented. */ virtual bool cancel () = 0 ; /** * @brief Virtual destructor for the interface */ virtual ~ CostmapRecovery (){} protected : CostmapRecovery (){} }; } /* namespace mbf_costmap_core */ #endif /* MBF_COSTMAP_CORE__COSTMAP_RECOVERY_H_ */ La classe d\u00e9finit les m\u00e9thodes virtuelles suivantes : initialize : fonction d'initialisation pour la r\u00e9cup\u00e9ration des co\u00fbts. Elle prend en entr\u00e9e un nom, un pointeur sur un \u00e9couteur de transformation, un pointeur sur la carte de co\u00fbts globale utilis\u00e9e par la pile de navigation et un pointeur sur la carte de co\u00fbts locale utilis\u00e9e par la pile de navigation. runBehavior : Ex\u00e9cute la r\u00e9cup\u00e9ration des co\u00fbts. La fonction prend en entr\u00e9e un message qui peut \u00eatre d\u00e9fini par le comportement de r\u00e9cup\u00e9ration, le message doit correspondre \u00e0 la valeur de retour. La fonction renvoie un code d'\u00e9tat qui sera transmis au r\u00e9sultat de l'action. cancel : demande au planificateur d'annuler, par exemple s'il prend trop de temps. La fonction retourne vrai si une annulation a \u00e9t\u00e9 demand\u00e9e avec succ\u00e8s, faux si elle n'est pas impl\u00e9ment\u00e9e. ~CostmapRecovery : destructeur virtuel pour l'interface. Les classes qui impl\u00e9mentent cette interface doivent d\u00e9finir les m\u00e9thodes initialize, runBehavior et \u00e9ventuellement cancel. La classe CostmapRecovery fournit \u00e9galement un type de pointeur partag\u00e9 pour faciliter la cr\u00e9ation d'instances de sous-classes. Nous allons cr\u00e9er un plugin que appeler rotate_recovery Notre classe doit h\u00e9riter de l\u2019interface mbf_costmap_core::CostmapRecovery class RotateRecovery : public mbf_costmap_core :: CostmapRecovery Dans un premier temps on int\u00e9grer la library permettant d\u2019exporter notre plugin #include <pluginlib/class_list_macros.h> On exporte notre plugin et l\u2019inteface mbf_costmap_core::CostmapRecovery: PLUGINLIB_EXPORT_CLASS ( rotate_recovery :: RotateRecovery , mbf_costmap_core :: CostmapRecovery ) PLUGINLIB_EXPORT_CLASS est une macro utilis\u00e9e par la biblioth\u00e8que pluginlib pour exporter une classe en tant que plugin pour qu'elle puisse \u00eatre d\u00e9couverte et utilis\u00e9e par d'autres applications. La macro permet de d\u00e9finir la classe (ici rotate_recovery::RotateRecovery) en tant que plugin avec une classe de base (ici mbf_costmap_core::CostmapRecovery). Cela signifie que les applications qui souhaitent utiliser ce plugin pouront le faire en s'attendant \u00e0 une interface compatible avec la classe de base. Notre classe doit donc contenir les methode suivante : virtual void initialize ( std :: string name , tf2_ros :: Buffer * , costmap_2d :: Costmap2DROS * , costmap_2d :: Costmap2DROS * local_costmap ); virtual uint32_t runBehavior ( std :: string & message ); virtual bool cancel (); ~ RotateRecovery (); Nous devons \u00e9galement cr\u00e9er un fichier XML pour enregistrer un plugin de comportement de r\u00e9cup\u00e9ration dans la biblioth\u00e8que de plugins ROS. Le plugin est d\u00e9fini par la classe \"rotate_recovery::RotateRecovery\" qui h\u00e9rite de la classe de base \"mbf_costmap_core::CostmapRecovery\". Le tag sp\u00e9cifie le chemin de la biblioth\u00e8que dynamique \"librotate_recovery\" qui contient le plugin. Le tag fournit des informations sur la classe, y compris son nom, son type et le type de sa classe de base. La description d\u00e9crira bri\u00e8vement ce que fait le comportement de r\u00e9cup\u00e9ration. <library path= \"lib/librotate_recovery\" > <class name= \"rotate_recovery/RotateRecovery\" type= \"rotate_recovery::RotateRecovery\" base_class_type= \"mbf_costmap_core::CostmapRecovery\" > <description> A recovery behavior that performs a 360 degree in-place rotation to attempt to clear out space. </description> </class> </library> Le pacquet du plugin doit ressembler \u00e0 ca: Dans le liens suivant le packet roate recovery complet: Rotate_recovery","title":"Plugin Custum"},{"location":"Setup/","text":"Cr\u00e9ations d\u2018un Workspace que nous allons appeler move_base_ws schema simplifier mkdir moveBase_ws cd moveBase_ws Cr\u00e9ation d\u2019un fichier source: mkdir src Dans source nous allons cr\u00e9er un fichier allons appeler mvb_ws: cd src mkdir mvb_pkg nous allons copier dans notre package les fichier source de navigation sudo git clone https://github.com/ros-planning/navigation.git Il est \u00e9galement possible d\u2019installer les fichier source directement avec apt-get XXXXX nous allons ajouter le paquet turtlebot 3 utilisants move_base sudo git clone https://github.com/ROBOTIS-GIT/turtlebot3.git Enfin nous allons cloner le paquet turtlebot permettant la simulation dans l'environnement 3d gazebo sudo git clone https://github.com/ROBOTIS-GIT/turtlebot3_simulations.git","title":"Setup"},{"location":"Sim/","text":"Launch File Pour commencer nous allons lanver une simulation gazebo dans le monde trurtlebot word 3 <launch> <arg name= \"model\" default= \"$(env TURTLEBOT3_MODEL)\" doc= \"model type [burger, waffle, waffle_pi]\" /> <arg name= \"x_pos\" default= \"-2.0\" /> <arg name= \"y_pos\" default= \"-0.5\" /> <arg name= \"z_pos\" default= \"0.0\" /> Ici, le launch file attend un argument \u201cmodel\u201d qui nous laisse le choix entre different modele de robot [burger, waffle, waffle_pi], ces mod\u00e8les sont present dans ls fichier models Les trois arguments suivatn x_pos, y_pos, et z_pos sont la position ou va apparaitre notre robot dans la map <include file= \"$(find gazebo_ros)/launch/empty_world.launch\" > <arg name= \"world_name\" value= \"$(find turtlebot3_gazebo)/worlds/turtlebot3_world.world\" /> <arg name= \"paused\" value= \"false\" /> <arg name= \"use_sim_time\" value= \"true\" /> <arg name= \"gui\" value= \"true\" /> <arg name= \"headless\" value= \"false\" /> <arg name= \"debug\" value= \"false\" /> </include> On inclu le launch file empty_word.launch qui va demarer une simulation, ce launch file prend plusieur argument d\u2019entr\u00e9e comme la map utilis\u00e9, \u201cword_name\u201d ici la valeur de notre argument va chercher un model monde present dans le fichier wordls. l\u2019agument \u201cgui\u201d mis a \u201ctrue\u201d permet de lancer l\u2019interface graphique de la simulation <param name= \"robot_description\" command= \"$(find xacro)/xacro --inorder $(find turtlebot3_description)/urdf/turtlebot3_$(arg model).urdf.xacro\" /> <node pkg= \"gazebo_ros\" type= \"spawn_model\" name= \"spawn_urdf\" args= \"-urdf -model turtlebot3_$(arg model) -x $(arg x_pos) -y $(arg y_pos) -z $(arg z_pos) -param robot_description\" /> </launch> Nous lan\u00e7ons le node spawn_urdf du packet gazebo_ros qui prend comme parametre \u201crobot description\u201d , ce param\u00e8tre pointe vers l\u2019urdf de notre robot ici, si nous choisision le robot burger, l\u2019urdf sera : turtlebot3_burger.urdf.xacro Ce fichier se trouve dans turtlebo3/turtlebot3_description/urdf , il est la description du robot au format URDF, dans l\u2019entete du fichier nous avons deux includes important: Lancement Nous allons lancer la simulation: On choisi le mod\u00e8le du robot que l\u2019on souhaite parmis la liste suivant [burger, waffle, waffle_pi] export TURTLEBOT3_MODEL=burger On lance la simulation: roslaunch turtlebot3_gazebo turtlebot3_world.launch Voici le r\u00e9sultsat du gui Gazeo","title":"Simulation"},{"location":"Sim/#launch-file","text":"Pour commencer nous allons lanver une simulation gazebo dans le monde trurtlebot word 3 <launch> <arg name= \"model\" default= \"$(env TURTLEBOT3_MODEL)\" doc= \"model type [burger, waffle, waffle_pi]\" /> <arg name= \"x_pos\" default= \"-2.0\" /> <arg name= \"y_pos\" default= \"-0.5\" /> <arg name= \"z_pos\" default= \"0.0\" /> Ici, le launch file attend un argument \u201cmodel\u201d qui nous laisse le choix entre different modele de robot [burger, waffle, waffle_pi], ces mod\u00e8les sont present dans ls fichier models Les trois arguments suivatn x_pos, y_pos, et z_pos sont la position ou va apparaitre notre robot dans la map <include file= \"$(find gazebo_ros)/launch/empty_world.launch\" > <arg name= \"world_name\" value= \"$(find turtlebot3_gazebo)/worlds/turtlebot3_world.world\" /> <arg name= \"paused\" value= \"false\" /> <arg name= \"use_sim_time\" value= \"true\" /> <arg name= \"gui\" value= \"true\" /> <arg name= \"headless\" value= \"false\" /> <arg name= \"debug\" value= \"false\" /> </include> On inclu le launch file empty_word.launch qui va demarer une simulation, ce launch file prend plusieur argument d\u2019entr\u00e9e comme la map utilis\u00e9, \u201cword_name\u201d ici la valeur de notre argument va chercher un model monde present dans le fichier wordls. l\u2019agument \u201cgui\u201d mis a \u201ctrue\u201d permet de lancer l\u2019interface graphique de la simulation <param name= \"robot_description\" command= \"$(find xacro)/xacro --inorder $(find turtlebot3_description)/urdf/turtlebot3_$(arg model).urdf.xacro\" /> <node pkg= \"gazebo_ros\" type= \"spawn_model\" name= \"spawn_urdf\" args= \"-urdf -model turtlebot3_$(arg model) -x $(arg x_pos) -y $(arg y_pos) -z $(arg z_pos) -param robot_description\" /> </launch> Nous lan\u00e7ons le node spawn_urdf du packet gazebo_ros qui prend comme parametre \u201crobot description\u201d , ce param\u00e8tre pointe vers l\u2019urdf de notre robot ici, si nous choisision le robot burger, l\u2019urdf sera : turtlebot3_burger.urdf.xacro Ce fichier se trouve dans turtlebo3/turtlebot3_description/urdf , il est la description du robot au format URDF, dans l\u2019entete du fichier nous avons deux includes important:","title":"Launch File"},{"location":"Sim/#lancement","text":"Nous allons lancer la simulation: On choisi le mod\u00e8le du robot que l\u2019on souhaite parmis la liste suivant [burger, waffle, waffle_pi] export TURTLEBOT3_MODEL=burger On lance la simulation: roslaunch turtlebot3_gazebo turtlebot3_world.launch Voici le r\u00e9sultsat du gui Gazeo","title":"Lancement"},{"location":"TF/","text":"TF statique Notre robot est compos\u00e9 de diff\u00e9rente corps ( flipper, roues, lidar ...) qui disposent chaqun de leur propre coordon\u00e9es. Pour visualiser notre robot dans l'espace il est necessaire de relier ces coorodn\u00e9es entre elles par le biai de transformation (TF). Dans notre cas, les diff\u00e9rents corps sont fixes les un des autres. Pour les relier on parle alors de TF statique. Pour r\u00e9aliser un TF statique nous pouvons utiliser le node robot_state_publisher et joint_state_publisher qui vont lire l'urdf de notre mod\u00e8le et creer les TF entre les different joints. Launch file <launch> <arg name= \"model\" default= \"$(find rescue_description)/urdf/rescue.xacro\" /> <arg name= \"gui\" default= \"true\" /> <arg name= \"rvizconfig\" default= \"$(find rescue_description)/launch/urdf.rviz\" /> <param name= \"robot_description\" command= \"$(find xacro)/xacro $(arg model)\" /> <param name= \"use_gui\" value= \"$(arg gui)\" /> <node name= \"joint_state_publisher\" pkg= \"joint_state_publisher\" type= \"joint_state_publisher\" /> <node name= \"robot_state_publisher\" pkg= \"robot_state_publisher\" type= \"robot_state_publisher\" /> <node name= \"rviz\" pkg= \"rviz\" args= \"-d $(arg rvizconfig)\" type= \"rviz\" required= \"true\" /> </launch> Lancement du launch file: roslaunch rescue_description display.launch","title":"Transformations"},{"location":"TF/#tf-statique","text":"Notre robot est compos\u00e9 de diff\u00e9rente corps ( flipper, roues, lidar ...) qui disposent chaqun de leur propre coordon\u00e9es. Pour visualiser notre robot dans l'espace il est necessaire de relier ces coorodn\u00e9es entre elles par le biai de transformation (TF). Dans notre cas, les diff\u00e9rents corps sont fixes les un des autres. Pour les relier on parle alors de TF statique. Pour r\u00e9aliser un TF statique nous pouvons utiliser le node robot_state_publisher et joint_state_publisher qui vont lire l'urdf de notre mod\u00e8le et creer les TF entre les different joints.","title":"TF statique"},{"location":"TF/#launch-file","text":"<launch> <arg name= \"model\" default= \"$(find rescue_description)/urdf/rescue.xacro\" /> <arg name= \"gui\" default= \"true\" /> <arg name= \"rvizconfig\" default= \"$(find rescue_description)/launch/urdf.rviz\" /> <param name= \"robot_description\" command= \"$(find xacro)/xacro $(arg model)\" /> <param name= \"use_gui\" value= \"$(arg gui)\" /> <node name= \"joint_state_publisher\" pkg= \"joint_state_publisher\" type= \"joint_state_publisher\" /> <node name= \"robot_state_publisher\" pkg= \"robot_state_publisher\" type= \"robot_state_publisher\" /> <node name= \"rviz\" pkg= \"rviz\" args= \"-d $(arg rvizconfig)\" type= \"rviz\" required= \"true\" /> </launch> Lancement du launch file: roslaunch rescue_description display.launch","title":"Launch file"},{"location":"URDF/","text":"Mod\u00e8le Corps Ci-dessous, les dimensions du corps du robot: Collision On genere un rectangle correpondant au corps du robot: L\u2019origine du corps se trouve au centre du rectangle, on souhaite d\u00e9caler cette origine pour la placer au niveau de l\u2019entraxe des roues, on decale donc l\u2019axe x de 0.2 m Sur gazebo il est important de distingu\u00e9 deux param\u00e8tres de g\u00e9om\u00e9trie: Visual et colision. Une g\u00e9ometrie \u201ccollision\u201d elle aura des param\u00e8tre physique et sera donc soumis au frottement, friction, gravit\u00e9.. <collision> <origin xyz= \"0.2 0 0.0\" rpy= \"0 0 0\" /> <geometry> <box size= \"0.6 0.420 0.115\" /> </geometry> </collision> Visuel Une g\u00e9ometrie \u201cvisual\u201d elle, sera purement visuel. Nous pouvons ajouter un mesh, un fichier 3D format STL que nous avons g\u00e9nerer avec un logicielle de CAO. <visual> <origin xyz= \"0.2 0 0.0\" rpy= \"0 0 -1.57\" /> <geometry> <mesh filename= \"package://rescue_description/meshes/base_link.stl\" scale= \"0.001 0.001 0.001\" /> </geometry> <material name= \"light_black\" /> </visual> Physique D\u00e9sormais nous devons definir l\u2019inertie de notre pi\u00e8ce. Notre corps est un rectangle, pour faciliter la t\u00e2che, nous pouvons inclure une macro qui calcul la matrice d\u2019inertie d\u2019un rectangle en fonction de sa masse et ses dimension. On y ajoute egalement l\u2019origine du corp. <xacro:macro name= \"box_inertia\" params= \"m w h d x y z\" > <inertial> <origin xyz= \"${x} ${y} ${z}\" rpy= \"${pi/2} 0 ${pi/2}\" /> <mass value= \"${m}\" /> <inertia ixx= \"${(m/12) * (h*h + d*d)}\" ixy= \"0.0\" ixz= \"0.0\" iyy= \"${(m/12) * (w*w + d*d)}\" iyz= \"0.0\" izz= \"${(m/12) * (w*w + h*h)}\" /> </inertial> </xacro:macro> Nous pouvons appeler la macro dans la definiton du corps <xacro:box_inertia m= \"1O\" w= \"0.420\" d= \"0.6\" h= \"0.115\" x= \"0.2\" y= \"0\" z= \"0\" /> Roue Les roues peuvent \u00eatre representer comme des cylindres. voici leur dimensions: On cr\u00e9er un link que l\u2019on appelle Roue_Droite <link name= \"Roue_Droite\" > On gen\u00e8re un cylindre avec les bonnes dimensions <cylinder length= \"0.0375\" radius= \"0.050\" /> On place l\u2019origine de la pi\u00e8ce en son centre: <origin xyz= \" 0 0 0\" rpy= \"0 0 0\" /> Pour l'assembler au corps, nous devons cr\u00e9er le joint entre la roue droite et le corps du robot. <joint name= \"Joint_Roue_Droite\" type= \"continuous\" > Le joint est de type \"continuous\u201d pour indiquer une rotation autour d\u2019un axe unique On definit les lien de parent\u00e9: <parent link= \"base_link\" /> <child link= \"Roue_Droite\" /> on definit l\u2019origine du joint Cette origine est la distance entre les origines du link p\u00e8re et m\u00e8re en prenant comme origne fixe celle du p\u00e8re On Sohaite d\u00e9caler la roue par rapport \u00e0 l'origine du corps: <origin xyz= \"0 -0.21 -0.065\" rpy= \"0 0 0\" /> On remarque que la roue n\u2019est pas orient\u00e9 correctement, il est necessaire de r\u00e9aliser une rotation de 90\u00b0 autour de l\u2019axe x rotation de 90\u00b0 = \u03c0/2 = 1.57 autour de l\u2019axe x et decalage en y (epaisseur de la roue): <origin xyz= \"0 -0.2285 -0.065\" rpy= \"-1.57 0 0\" /> Enfin , on definit l\u2019axe de rotation de notre roue, ici, l\u2019axe z <axis xyz= \"0 0 1\" /> Footprint Le footprint du robot definit l\u2019empreinte du robot dans l\u2019espace. Ce param\u00e8tre permet aux algorithme de navigation de connaitre les dimensions du robot. La d\u00e9limitation se d\u00e9finit en 4 point A,B,C,D footprint: [[A], [B], [C], [D]] Nous devons choisir des points qui permettent de couvrir l\u2019integralit\u00e9 de l'espace pris par le robot L\u2019origine se base par rapport au base_link definit pr\u00e9c\u00e9demment. Dans l\u2019exemple ci-dessous nous avons represent\u00e9 les 4 points correspondant aux angle du corps du robot Le footprint correspondant est le suivant: footprint: [[-0.1,-0.21], [-0.1,0.21], [0.5,0.21], [0.5,-0.21]] Pour couvrir le robot et ajouter une zone securit\u00e9 nous allons utilise\u00e9 un footprint l\u00e9g\u00e8rement plus grand: footprint: [[-0.12,-0.23], [-0.12,0.23], [0.52,0.23], [0.52,-0.23]] Assemblage complet De la m\u00eame mani\u00e8re que pour les roues et le corps on ajoute a notre modele, les flipper, une roues libre, le lidar et la cam\u00e9ra toue les joints sont des joint fixes enfant du link corps arborescence corps roue_droite roue_gauche flipper_droit flipper_gauche roue_libre cam\u00e9ra lidar Dans le lien github suivant le mod\u00e8le complet GitHub","title":"Mod\u00e8le"},{"location":"URDF/#modele","text":"","title":"Mod\u00e8le"},{"location":"URDF/#corps","text":"Ci-dessous, les dimensions du corps du robot:","title":"Corps"},{"location":"URDF/#collision","text":"On genere un rectangle correpondant au corps du robot: L\u2019origine du corps se trouve au centre du rectangle, on souhaite d\u00e9caler cette origine pour la placer au niveau de l\u2019entraxe des roues, on decale donc l\u2019axe x de 0.2 m Sur gazebo il est important de distingu\u00e9 deux param\u00e8tres de g\u00e9om\u00e9trie: Visual et colision. Une g\u00e9ometrie \u201ccollision\u201d elle aura des param\u00e8tre physique et sera donc soumis au frottement, friction, gravit\u00e9.. <collision> <origin xyz= \"0.2 0 0.0\" rpy= \"0 0 0\" /> <geometry> <box size= \"0.6 0.420 0.115\" /> </geometry> </collision>","title":"Collision"},{"location":"URDF/#visuel","text":"Une g\u00e9ometrie \u201cvisual\u201d elle, sera purement visuel. Nous pouvons ajouter un mesh, un fichier 3D format STL que nous avons g\u00e9nerer avec un logicielle de CAO. <visual> <origin xyz= \"0.2 0 0.0\" rpy= \"0 0 -1.57\" /> <geometry> <mesh filename= \"package://rescue_description/meshes/base_link.stl\" scale= \"0.001 0.001 0.001\" /> </geometry> <material name= \"light_black\" /> </visual>","title":"Visuel"},{"location":"URDF/#physique","text":"D\u00e9sormais nous devons definir l\u2019inertie de notre pi\u00e8ce. Notre corps est un rectangle, pour faciliter la t\u00e2che, nous pouvons inclure une macro qui calcul la matrice d\u2019inertie d\u2019un rectangle en fonction de sa masse et ses dimension. On y ajoute egalement l\u2019origine du corp. <xacro:macro name= \"box_inertia\" params= \"m w h d x y z\" > <inertial> <origin xyz= \"${x} ${y} ${z}\" rpy= \"${pi/2} 0 ${pi/2}\" /> <mass value= \"${m}\" /> <inertia ixx= \"${(m/12) * (h*h + d*d)}\" ixy= \"0.0\" ixz= \"0.0\" iyy= \"${(m/12) * (w*w + d*d)}\" iyz= \"0.0\" izz= \"${(m/12) * (w*w + h*h)}\" /> </inertial> </xacro:macro> Nous pouvons appeler la macro dans la definiton du corps <xacro:box_inertia m= \"1O\" w= \"0.420\" d= \"0.6\" h= \"0.115\" x= \"0.2\" y= \"0\" z= \"0\" />","title":"Physique"},{"location":"URDF/#roue","text":"Les roues peuvent \u00eatre representer comme des cylindres. voici leur dimensions: On cr\u00e9er un link que l\u2019on appelle Roue_Droite <link name= \"Roue_Droite\" > On gen\u00e8re un cylindre avec les bonnes dimensions <cylinder length= \"0.0375\" radius= \"0.050\" /> On place l\u2019origine de la pi\u00e8ce en son centre: <origin xyz= \" 0 0 0\" rpy= \"0 0 0\" /> Pour l'assembler au corps, nous devons cr\u00e9er le joint entre la roue droite et le corps du robot. <joint name= \"Joint_Roue_Droite\" type= \"continuous\" > Le joint est de type \"continuous\u201d pour indiquer une rotation autour d\u2019un axe unique On definit les lien de parent\u00e9: <parent link= \"base_link\" /> <child link= \"Roue_Droite\" /> on definit l\u2019origine du joint Cette origine est la distance entre les origines du link p\u00e8re et m\u00e8re en prenant comme origne fixe celle du p\u00e8re On Sohaite d\u00e9caler la roue par rapport \u00e0 l'origine du corps: <origin xyz= \"0 -0.21 -0.065\" rpy= \"0 0 0\" /> On remarque que la roue n\u2019est pas orient\u00e9 correctement, il est necessaire de r\u00e9aliser une rotation de 90\u00b0 autour de l\u2019axe x rotation de 90\u00b0 = \u03c0/2 = 1.57 autour de l\u2019axe x et decalage en y (epaisseur de la roue): <origin xyz= \"0 -0.2285 -0.065\" rpy= \"-1.57 0 0\" /> Enfin , on definit l\u2019axe de rotation de notre roue, ici, l\u2019axe z <axis xyz= \"0 0 1\" />","title":"Roue"},{"location":"URDF/#footprint","text":"Le footprint du robot definit l\u2019empreinte du robot dans l\u2019espace. Ce param\u00e8tre permet aux algorithme de navigation de connaitre les dimensions du robot. La d\u00e9limitation se d\u00e9finit en 4 point A,B,C,D footprint: [[A], [B], [C], [D]] Nous devons choisir des points qui permettent de couvrir l\u2019integralit\u00e9 de l'espace pris par le robot L\u2019origine se base par rapport au base_link definit pr\u00e9c\u00e9demment. Dans l\u2019exemple ci-dessous nous avons represent\u00e9 les 4 points correspondant aux angle du corps du robot Le footprint correspondant est le suivant: footprint: [[-0.1,-0.21], [-0.1,0.21], [0.5,0.21], [0.5,-0.21]] Pour couvrir le robot et ajouter une zone securit\u00e9 nous allons utilise\u00e9 un footprint l\u00e9g\u00e8rement plus grand: footprint: [[-0.12,-0.23], [-0.12,0.23], [0.52,0.23], [0.52,-0.23]]","title":"Footprint"},{"location":"URDF/#_1","text":"","title":""},{"location":"URDF/#_2","text":"","title":""},{"location":"URDF/#_3","text":"","title":""},{"location":"URDF/#_4","text":"","title":""},{"location":"URDF/#_5","text":"","title":""},{"location":"URDF/#_6","text":"","title":""},{"location":"URDF/#_7","text":"","title":""},{"location":"URDF/#_8","text":"","title":""},{"location":"URDF/#assemblage-complet","text":"De la m\u00eame mani\u00e8re que pour les roues et le corps on ajoute a notre modele, les flipper, une roues libre, le lidar et la cam\u00e9ra toue les joints sont des joint fixes enfant du link corps","title":"Assemblage complet"},{"location":"URDF/#arborescence","text":"corps roue_droite roue_gauche flipper_droit flipper_gauche roue_libre cam\u00e9ra lidar Dans le lien github suivant le mod\u00e8le complet GitHub","title":"arborescence"}]}